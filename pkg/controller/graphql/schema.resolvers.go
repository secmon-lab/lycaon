package graphql

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.78

import (
	"context"
	"fmt"
	"strconv"
	"time"

	goerr "github.com/m-mizutani/goerr/v2"
	"github.com/secmon-lab/lycaon/pkg/domain/model"
	graphql1 "github.com/secmon-lab/lycaon/pkg/domain/model/graphql"
	"github.com/secmon-lab/lycaon/pkg/domain/types"
	"github.com/secmon-lab/lycaon/pkg/repository"
	"github.com/secmon-lab/lycaon/pkg/utils/apperr"
)

// ID is the resolver for the id field.
func (r *incidentResolver) ID(ctx context.Context, obj *model.Incident) (string, error) {
	return fmt.Sprintf("%d", obj.ID), nil
}

// ChannelID is the resolver for the channelId field.
func (r *incidentResolver) ChannelID(ctx context.Context, obj *model.Incident) (string, error) {
	return string(obj.ChannelID), nil
}

// ChannelName is the resolver for the channelName field.
func (r *incidentResolver) ChannelName(ctx context.Context, obj *model.Incident) (string, error) {
	return string(obj.ChannelName), nil
}

// CategoryName is the resolver for the categoryName field.
func (r *incidentResolver) CategoryName(ctx context.Context, obj *model.Incident) (string, error) {
	if r.categories != nil {
		if category := r.categories.FindCategoryByID(obj.CategoryID); category != nil {
			return category.Name, nil
		}
	}
	// Return the category ID if no name is found
	return obj.CategoryID, nil
}

// Status is the resolver for the status field.
func (r *incidentResolver) Status(ctx context.Context, obj *model.Incident) (*types.IncidentStatus, error) {
	if obj.Status == "" {
		return nil, nil
	}
	return &obj.Status, nil
}

// Lead is the resolver for the lead field.
func (r *incidentResolver) Lead(ctx context.Context, obj *model.Incident) (*string, error) {
	if obj.Lead == "" {
		return nil, nil
	}
	lead := string(obj.Lead)
	return &lead, nil
}

// LeadUser is the resolver for the leadUser field.
func (r *incidentResolver) LeadUser(ctx context.Context, obj *model.Incident) (*model.User, error) {
	if r.userUC == nil || obj.Lead == "" {
		return nil, nil
	}

	user, err := r.userUC.GetOrFetchUser(ctx, obj.Lead)
	if err != nil {
		// Log the error for monitoring but don't fail the entire query
		apperr.Handle(ctx, err)
		// Return a fallback user with minimal information
		// This ensures the UI can still display something useful
		return &model.User{
			ID:    types.UserID(obj.Lead),
			Name:  string(obj.Lead),
			Email: "",
		}, nil
	}

	return user, nil
}

// OriginChannelID is the resolver for the originChannelId field.
func (r *incidentResolver) OriginChannelID(ctx context.Context, obj *model.Incident) (string, error) {
	return string(obj.OriginChannelID), nil
}

// OriginChannelName is the resolver for the originChannelName field.
func (r *incidentResolver) OriginChannelName(ctx context.Context, obj *model.Incident) (string, error) {
	return string(obj.OriginChannelName), nil
}

// TeamID is the resolver for the teamId field.
func (r *incidentResolver) TeamID(ctx context.Context, obj *model.Incident) (*string, error) {
	if obj.TeamID == "" {
		return nil, nil
	}
	teamID := string(obj.TeamID)
	return &teamID, nil
}

// CreatedBy is the resolver for the createdBy field.
func (r *incidentResolver) CreatedBy(ctx context.Context, obj *model.Incident) (string, error) {
	return string(obj.CreatedBy), nil
}

// CreatedByUser is the resolver for the createdByUser field.
func (r *incidentResolver) CreatedByUser(ctx context.Context, obj *model.Incident) (*model.User, error) {
	if r.userUC == nil || obj.CreatedBy == "" {
		return nil, nil
	}

	user, err := r.userUC.GetOrFetchUser(ctx, obj.CreatedBy)
	if err != nil {
		// Log the error for monitoring but don't fail the entire query
		apperr.Handle(ctx, err)
		// Return a fallback user with minimal information
		// This ensures the UI can still display something useful
		return &model.User{
			ID:    types.UserID(obj.CreatedBy),
			Name:  string(obj.CreatedBy),
			Email: "",
		}, nil
	}

	return user, nil
}

// UpdatedAt is the resolver for the updatedAt field.
func (r *incidentResolver) UpdatedAt(ctx context.Context, obj *model.Incident) (*time.Time, error) {
	// Use CreatedAt as UpdatedAt for now - could be enhanced with proper update tracking
	return &obj.CreatedAt, nil
}

// StatusHistories is the resolver for the statusHistories field.
func (r *incidentResolver) StatusHistories(ctx context.Context, obj *model.Incident) ([]*model.StatusHistory, error) {
	if r.statusUC == nil {
		return nil, nil
	}

	// Get status history with user information
	historiesWithUser, err := r.statusUC.GetStatusHistory(ctx, obj.ID)
	if err != nil {
		return nil, goerr.Wrap(err, "failed to get status history")
	}

	// Convert to StatusHistory slice
	histories := make([]*model.StatusHistory, len(historiesWithUser))
	for i, hwu := range historiesWithUser {
		histories[i] = &hwu.StatusHistory
	}

	return histories, nil
}

// Tasks is the resolver for the tasks field.
func (r *incidentResolver) Tasks(ctx context.Context, obj *model.Incident) ([]*model.Task, error) {
	return r.repo.ListTasksByIncident(ctx, obj.ID)
}

// UpdateIncident is the resolver for the updateIncident field.
func (r *mutationResolver) UpdateIncident(ctx context.Context, id string, input graphql1.UpdateIncidentInput) (*model.Incident, error) {
	// Parse incident ID
	incidentIDInt, err := strconv.Atoi(id)
	if err != nil {
		return nil, goerr.Wrap(err, "invalid incident ID")
	}
	incidentID := types.IncidentID(incidentIDInt)

	// Check if repository is Firestore for atomic update
	if firestoreRepo, ok := r.repo.(*repository.Firestore); ok {
		// Use atomic transaction for Firestore
		var updatedIncident *model.Incident
		err := firestoreRepo.UpdateIncidentAtomic(ctx, incidentID, func(incident *model.Incident) error {
			// Update fields if provided
			if input.Title != nil {
				incident.Title = *input.Title
			}
			if input.Description != nil {
				incident.Description = *input.Description
			}
			if input.Lead != nil {
				incident.Lead = types.SlackUserID(*input.Lead)
			}
			updatedIncident = incident
			return nil
		})
		if err != nil {
			return nil, goerr.Wrap(err, "failed to update incident", goerr.V("incidentID", incidentID))
		}
		return updatedIncident, nil
	}

	// Fallback to non-atomic update for other repositories (e.g., Memory for testing)
	incident, err := r.repo.GetIncident(ctx, incidentID)
	if err != nil {
		return nil, goerr.Wrap(err, "failed to get incident", goerr.V("incidentID", incidentID))
	}

	// Update fields if provided
	if input.Title != nil {
		incident.Title = *input.Title
	}
	if input.Description != nil {
		incident.Description = *input.Description
	}
	if input.Lead != nil {
		incident.Lead = types.SlackUserID(*input.Lead)
	}

	// Save updated incident
	if err := r.repo.PutIncident(ctx, incident); err != nil {
		return nil, goerr.Wrap(err, "failed to update incident", goerr.V("incidentID", incidentID))
	}

	return incident, nil
}

// UpdateIncidentStatus is the resolver for the updateIncidentStatus field.
func (r *mutationResolver) UpdateIncidentStatus(ctx context.Context, incidentID string, status types.IncidentStatus, note *string) (*model.Incident, error) {
	// Parse incident ID
	incidentIDInt, err := strconv.Atoi(incidentID)
	if err != nil {
		return nil, goerr.Wrap(err, "invalid incident ID")
	}
	id := types.IncidentID(incidentIDInt)

	// Get the authenticated user from context
	var userID types.SlackUserID
	if authCtx, ok := model.GetAuthContext(ctx); ok && authCtx != nil {
		if authCtx.SessionID != "" {
			user, err := r.authUC.GetUserFromSession(ctx, authCtx.SessionID)
			if err == nil && user != nil {
				userID = types.SlackUserID(user.ID)
			}
		}
	}

	// Fall back to "system" if no user found
	if userID == "" {
		userID = types.SlackUserID("system")
	}

	// Prepare note string
	noteStr := ""
	if note != nil {
		noteStr = *note
	}

	// Update status using StatusUseCase
	if err := r.statusUC.UpdateStatus(ctx, id, status, userID, noteStr); err != nil {
		return nil, goerr.Wrap(err, "failed to update incident status")
	}

	// Return updated incident
	return r.repo.GetIncident(ctx, id)
}

// CreateTask is the resolver for the createTask field.
func (r *mutationResolver) CreateTask(ctx context.Context, input graphql1.CreateTaskInput) (*model.Task, error) {
	// Parse incident ID
	incidentIDInt, err := strconv.Atoi(input.IncidentID)
	if err != nil {
		return nil, goerr.Wrap(err, "invalid incident ID")
	}
	incidentID := types.IncidentID(incidentIDInt)

	// Validate incident exists
	_, err = r.repo.GetIncident(ctx, incidentID)
	if err != nil {
		return nil, goerr.Wrap(err, "incident not found", goerr.V("incidentID", incidentID))
	}

	// Get the authenticated user from context
	var slackUserID types.SlackUserID
	if authCtx, ok := model.GetAuthContext(ctx); ok && authCtx != nil {
		// Get user from session
		if authCtx.SessionID != "" {
			user, err := r.authUC.GetUserFromSession(ctx, authCtx.SessionID)
			if err == nil && user != nil {
				slackUserID = types.SlackUserID(user.ID)
			}
		}
	}

	// Fall back to "system" if no user found
	if slackUserID == "" {
		slackUserID = types.SlackUserID("system")
	}

	// Create task using TaskUC
	task, err := r.taskUC.CreateTask(ctx, incidentID, input.Title, slackUserID, types.ChannelID(""), "")
	if err != nil {
		return nil, goerr.Wrap(err, "failed to create task")
	}

	// Set description if provided
	if input.Description != nil {
		task.UpdateDescription(*input.Description)
		if err := r.repo.UpdateTask(ctx, task); err != nil {
			return nil, goerr.Wrap(err, "failed to update task description")
		}
	}

	return task, nil
}

// UpdateTask is the resolver for the updateTask field.
func (r *mutationResolver) UpdateTask(ctx context.Context, id string, input graphql1.UpdateTaskInput) (*model.Task, error) {
	// Parse task ID
	taskID := types.TaskID(id)

	// First get the task to retrieve its IncidentID
	task, err := r.repo.GetTask(ctx, taskID)
	if err != nil {
		return nil, goerr.Wrap(err, "failed to get task", goerr.V("taskID", taskID))
	}
	incidentID := task.IncidentID

	// Check if repository is Firestore for atomic update
	if firestoreRepo, ok := r.repo.(*repository.Firestore); ok {
		// Use atomic transaction for Firestore
		var updatedTask *model.Task
		err := firestoreRepo.UpdateTaskAtomic(ctx, incidentID, taskID, func(task *model.Task) error {
			// Update fields if provided
			if input.Title != nil {
				if err := task.UpdateTitle(*input.Title); err != nil {
					return goerr.Wrap(err, "failed to update task title")
				}
			}
			if input.Description != nil {
				task.UpdateDescription(*input.Description)
			}
			if input.Status != nil {
				status := model.TaskStatus(*input.Status)
				if err := task.UpdateStatus(status); err != nil {
					return goerr.Wrap(err, "failed to update task status")
				}
			}
			updatedTask = task
			return nil
		})
		if err != nil {
			return nil, goerr.Wrap(err, "failed to update task", goerr.V("taskID", taskID))
		}
		return updatedTask, nil
	}

	// Fallback to non-atomic update for other repositories (e.g., Memory for testing)
	// Update fields if provided
	if input.Title != nil {
		if err := task.UpdateTitle(*input.Title); err != nil {
			return nil, goerr.Wrap(err, "failed to update task title")
		}
	}
	if input.Description != nil {
		task.UpdateDescription(*input.Description)
	}
	if input.Status != nil {
		status := model.TaskStatus(*input.Status)
		if err := task.UpdateStatus(status); err != nil {
			return nil, goerr.Wrap(err, "failed to update task status")
		}
	}

	// Save updated task
	if err := r.repo.UpdateTask(ctx, task); err != nil {
		return nil, goerr.Wrap(err, "failed to save updated task", goerr.V("taskID", taskID))
	}

	return task, nil
}

// DeleteTask is the resolver for the deleteTask field.
func (r *mutationResolver) DeleteTask(ctx context.Context, id string) (bool, error) {
	// Parse task ID
	taskID := types.TaskID(id)

	// Get task to retrieve its IncidentID
	task, err := r.repo.GetTask(ctx, taskID)
	if err != nil {
		return false, goerr.Wrap(err, "failed to get task", goerr.V("taskID", taskID))
	}

	// Delete task using both IncidentID and TaskID for efficient deletion
	if err := r.repo.DeleteTask(ctx, task.IncidentID, taskID); err != nil {
		return false, goerr.Wrap(err, "failed to delete task", goerr.V("taskID", taskID))
	}

	return true, nil
}

// Incidents is the resolver for the incidents field.
func (r *queryResolver) Incidents(ctx context.Context, first *int, after *string) (*graphql1.IncidentConnection, error) {
	// Build pagination options
	opts := types.PaginationOptions{
		Limit: 20, // Default limit
	}

	// Apply first parameter if provided
	if first != nil && *first > 0 {
		opts.Limit = *first
		if opts.Limit > 100 {
			opts.Limit = 100 // Cap at 100
		}
	}

	// Parse and apply cursor if provided
	if after != nil && *after != "" {
		// Parse the cursor (which is the incident ID)
		incidentID, err := strconv.ParseInt(*after, 10, 64)
		if err != nil {
			return nil, goerr.Wrap(err, "invalid cursor", goerr.V("cursor", *after))
		}
		id := types.IncidentID(incidentID)
		opts.After = &id
	}

	// Get paginated incidents from repository
	incidents, pageResult, err := r.repo.ListIncidentsPaginated(ctx, opts)
	if err != nil {
		return nil, goerr.Wrap(err, "failed to list incidents")
	}

	// Create edges
	edges := make([]*graphql1.IncidentEdge, len(incidents))
	for i, incident := range incidents {
		edges[i] = &graphql1.IncidentEdge{
			Node:   incident,
			Cursor: fmt.Sprintf("%d", incident.ID),
		}
	}

	// Create page info
	pageInfo := &graphql1.PageInfo{
		HasNextPage:     pageResult.HasNextPage,
		HasPreviousPage: pageResult.HasPreviousPage,
		StartCursor:     nil,
		EndCursor:       nil,
	}

	if len(edges) > 0 {
		startCursor := edges[0].Cursor
		endCursor := edges[len(edges)-1].Cursor
		pageInfo.StartCursor = &startCursor
		pageInfo.EndCursor = &endCursor
	}

	return &graphql1.IncidentConnection{
		Edges:      edges,
		PageInfo:   pageInfo,
		TotalCount: pageResult.TotalCount,
	}, nil
}

// Incident is the resolver for the incident field.
func (r *queryResolver) Incident(ctx context.Context, id string) (*model.Incident, error) {
	incidentID, err := strconv.ParseInt(id, 10, 64)
	if err != nil {
		return nil, goerr.Wrap(err, "invalid incident ID")
	}
	return r.repo.GetIncident(ctx, types.IncidentID(incidentID))
}

// IncidentStatusHistory is the resolver for the incidentStatusHistory field.
func (r *queryResolver) IncidentStatusHistory(ctx context.Context, incidentID string) ([]*model.StatusHistory, error) {
	// Parse incident ID
	incidentIDInt, err := strconv.Atoi(incidentID)
	if err != nil {
		return nil, goerr.Wrap(err, "invalid incident ID")
	}
	id := types.IncidentID(incidentIDInt)

	// Get status history with user information
	historiesWithUser, err := r.statusUC.GetStatusHistory(ctx, id)
	if err != nil {
		return nil, goerr.Wrap(err, "failed to get status history")
	}

	// Convert to StatusHistory slice
	histories := make([]*model.StatusHistory, len(historiesWithUser))
	for i, hwu := range historiesWithUser {
		histories[i] = &hwu.StatusHistory
	}

	return histories, nil
}

// Tasks is the resolver for the tasks field.
func (r *queryResolver) Tasks(ctx context.Context, incidentID string) ([]*model.Task, error) {
	id, err := strconv.ParseInt(incidentID, 10, 64)
	if err != nil {
		return nil, goerr.Wrap(err, "invalid incident ID")
	}
	return r.repo.ListTasksByIncident(ctx, types.IncidentID(id))
}

// Task is the resolver for the task field.
func (r *queryResolver) Task(ctx context.Context, id string) (*model.Task, error) {
	return r.repo.GetTask(ctx, types.TaskID(id))
}

// ChannelMembers is the resolver for the channelMembers field.
func (r *queryResolver) ChannelMembers(ctx context.Context, channelID string) ([]*model.User, error) {
	return r.authUC.GetChannelMembers(ctx, channelID)
}

// ID is the resolver for the id field.
func (r *statusHistoryResolver) ID(ctx context.Context, obj *model.StatusHistory) (string, error) {
	return string(obj.ID), nil
}

// IncidentID is the resolver for the incidentId field.
func (r *statusHistoryResolver) IncidentID(ctx context.Context, obj *model.StatusHistory) (string, error) {
	return fmt.Sprintf("%d", obj.IncidentID), nil
}

// ChangedBy is the resolver for the changedBy field.
func (r *statusHistoryResolver) ChangedBy(ctx context.Context, obj *model.StatusHistory) (*model.User, error) {
	if r.userUC == nil || obj.ChangedBy == "" {
		return nil, nil
	}

	user, err := r.userUC.GetOrFetchUser(ctx, obj.ChangedBy)
	if err != nil {
		// Log the error for monitoring but don't fail the entire query
		apperr.Handle(ctx, err)
		// Return a fallback user with minimal information
		// This ensures the UI can still display something useful
		return &model.User{
			ID:    types.UserID(obj.ChangedBy),
			Name:  string(obj.ChangedBy),
			Email: "",
		}, nil
	}

	return user, nil
}

// ID is the resolver for the id field.
func (r *taskResolver) ID(ctx context.Context, obj *model.Task) (string, error) {
	return string(obj.ID), nil
}

// IncidentID is the resolver for the incidentId field.
func (r *taskResolver) IncidentID(ctx context.Context, obj *model.Task) (string, error) {
	return fmt.Sprintf("%d", obj.IncidentID), nil
}

// AssigneeID is the resolver for the assigneeId field.
func (r *taskResolver) AssigneeID(ctx context.Context, obj *model.Task) (*string, error) {
	if obj.AssigneeID == "" {
		return nil, nil
	}
	assignee := string(obj.AssigneeID)
	return &assignee, nil
}

// AssigneeUser is the resolver for the assigneeUser field.
func (r *taskResolver) AssigneeUser(ctx context.Context, obj *model.Task) (*model.User, error) {
	if r.userUC == nil || obj.AssigneeID == "" {
		return nil, nil
	}

	user, err := r.userUC.GetOrFetchUser(ctx, obj.AssigneeID)
	if err != nil {
		// Log the error for monitoring but don't fail the entire query
		apperr.Handle(ctx, err)
		// Return a fallback user with minimal information
		// This ensures the UI can still display something useful
		return &model.User{
			ID:    types.UserID(obj.AssigneeID),
			Name:  string(obj.AssigneeID),
			Email: "",
		}, nil
	}

	return user, nil
}

// CreatedBy is the resolver for the createdBy field.
func (r *taskResolver) CreatedBy(ctx context.Context, obj *model.Task) (string, error) {
	return string(obj.CreatedBy), nil
}

// ChannelID is the resolver for the channelId field.
func (r *taskResolver) ChannelID(ctx context.Context, obj *model.Task) (string, error) {
	return string(obj.ChannelID), nil
}

// ID is the resolver for the id field.
func (r *userResolver) ID(ctx context.Context, obj *model.User) (string, error) {
	return string(obj.ID), nil
}

// SlackUserID is the resolver for the slackUserId field.
// Since User.ID is now the Slack User ID, we return the ID
func (r *userResolver) SlackUserID(ctx context.Context, obj *model.User) (string, error) {
	return string(obj.ID), nil
}

// Incident returns IncidentResolver implementation.
func (r *Resolver) Incident() IncidentResolver { return &incidentResolver{r} }

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

// StatusHistory returns StatusHistoryResolver implementation.
func (r *Resolver) StatusHistory() StatusHistoryResolver { return &statusHistoryResolver{r} }

// Task returns TaskResolver implementation.
func (r *Resolver) Task() TaskResolver { return &taskResolver{r} }

// User returns UserResolver implementation.
func (r *Resolver) User() UserResolver { return &userResolver{r} }

type incidentResolver struct{ *Resolver }
type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type statusHistoryResolver struct{ *Resolver }
type taskResolver struct{ *Resolver }
type userResolver struct{ *Resolver }
