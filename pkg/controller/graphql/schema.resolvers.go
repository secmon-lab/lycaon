package graphql

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.78

import (
	"context"
	"fmt"
	"strconv"
	"time"

	goerr "github.com/m-mizutani/goerr/v2"
	"github.com/secmon-lab/lycaon/pkg/domain/model"
	graphql1 "github.com/secmon-lab/lycaon/pkg/domain/model/graphql"
	"github.com/secmon-lab/lycaon/pkg/domain/types"
)

// ID is the resolver for the id field.
func (r *incidentResolver) ID(ctx context.Context, obj *model.Incident) (string, error) {
	return fmt.Sprintf("%d", obj.ID), nil
}

// ChannelID is the resolver for the channelId field.
func (r *incidentResolver) ChannelID(ctx context.Context, obj *model.Incident) (string, error) {
	return string(obj.ChannelID), nil
}

// ChannelName is the resolver for the channelName field.
func (r *incidentResolver) ChannelName(ctx context.Context, obj *model.Incident) (string, error) {
	return string(obj.ChannelName), nil
}

// CategoryName is the resolver for the categoryName field.
func (r *incidentResolver) CategoryName(ctx context.Context, obj *model.Incident) (string, error) {
	if r.categories != nil {
		if category := r.categories.FindCategoryByID(obj.CategoryID); category != nil {
			return category.Name, nil
		}
	}
	// Return the category ID if no name is found
	return obj.CategoryID, nil
}

// Status is the resolver for the status field.
func (r *incidentResolver) Status(ctx context.Context, obj *model.Incident) (string, error) {
	// Default status for incidents - this could be enhanced with a proper status field later
	return "open", nil
}

// OriginChannelID is the resolver for the originChannelId field.
func (r *incidentResolver) OriginChannelID(ctx context.Context, obj *model.Incident) (string, error) {
	return string(obj.OriginChannelID), nil
}

// OriginChannelName is the resolver for the originChannelName field.
func (r *incidentResolver) OriginChannelName(ctx context.Context, obj *model.Incident) (string, error) {
	return string(obj.OriginChannelName), nil
}

// CreatedBy is the resolver for the createdBy field.
func (r *incidentResolver) CreatedBy(ctx context.Context, obj *model.Incident) (string, error) {
	return string(obj.CreatedBy), nil
}

// CreatedByUser is the resolver for the createdByUser field.
func (r *incidentResolver) CreatedByUser(ctx context.Context, obj *model.Incident) (*model.User, error) {
	if r.userUC == nil {
		return nil, nil
	}

	user, err := r.userUC.GetOrFetchUser(ctx, obj.CreatedBy)
	if err != nil {
		// Log error but don't fail - return nil instead
		return nil, nil
	}

	return user, nil
}

// UpdatedAt is the resolver for the updatedAt field.
func (r *incidentResolver) UpdatedAt(ctx context.Context, obj *model.Incident) (*time.Time, error) {
	// Use CreatedAt as UpdatedAt for now - could be enhanced with proper update tracking
	return &obj.CreatedAt, nil
}

// Tasks is the resolver for the tasks field.
func (r *incidentResolver) Tasks(ctx context.Context, obj *model.Incident) ([]*model.Task, error) {
	return r.repo.ListTasksByIncident(ctx, obj.ID)
}

// UpdateIncident is the resolver for the updateIncident field.
func (r *mutationResolver) UpdateIncident(ctx context.Context, id string, input graphql1.UpdateIncidentInput) (*model.Incident, error) {
	// Parse incident ID
	incidentIDInt, err := strconv.Atoi(id)
	if err != nil {
		return nil, goerr.Wrap(err, "invalid incident ID")
	}
	incidentID := types.IncidentID(incidentIDInt)

	// Get existing incident
	incident, err := r.repo.GetIncident(ctx, incidentID)
	if err != nil {
		return nil, goerr.Wrap(err, "failed to get incident", goerr.V("incidentID", incidentID))
	}

	// Update fields if provided
	if input.Title != nil {
		incident.Title = *input.Title
	}
	if input.Description != nil {
		incident.Description = *input.Description
	}

	// Save updated incident
	if err := r.repo.PutIncident(ctx, incident); err != nil {
		return nil, goerr.Wrap(err, "failed to update incident", goerr.V("incidentID", incidentID))
	}

	return incident, nil
}

// CreateTask is the resolver for the createTask field.
func (r *mutationResolver) CreateTask(ctx context.Context, input graphql1.CreateTaskInput) (*model.Task, error) {
	// Parse incident ID
	incidentIDInt, err := strconv.Atoi(input.IncidentID)
	if err != nil {
		return nil, goerr.Wrap(err, "invalid incident ID")
	}
	incidentID := types.IncidentID(incidentIDInt)

	// Validate incident exists
	_, err = r.repo.GetIncident(ctx, incidentID)
	if err != nil {
		return nil, goerr.Wrap(err, "incident not found", goerr.V("incidentID", incidentID))
	}

	// Create task using TaskUC
	task, err := r.taskUC.CreateTask(ctx, incidentID, input.Title, types.SlackUserID("system"), types.ChannelID(""), "")
	if err != nil {
		return nil, goerr.Wrap(err, "failed to create task")
	}

	// Set description if provided
	if input.Description != nil {
		task.UpdateDescription(*input.Description)
		if err := r.repo.UpdateTask(ctx, task); err != nil {
			return nil, goerr.Wrap(err, "failed to update task description")
		}
	}

	return task, nil
}

// UpdateTask is the resolver for the updateTask field.
func (r *mutationResolver) UpdateTask(ctx context.Context, id string, input graphql1.UpdateTaskInput) (*model.Task, error) {
	// Parse task ID
	taskID := types.TaskID(id)

	// Get existing task
	task, err := r.repo.GetTask(ctx, taskID)
	if err != nil {
		return nil, goerr.Wrap(err, "failed to get task", goerr.V("taskID", taskID))
	}

	// Update fields if provided
	if input.Title != nil {
		if err := task.UpdateTitle(*input.Title); err != nil {
			return nil, goerr.Wrap(err, "failed to update task title")
		}
	}
	if input.Description != nil {
		task.UpdateDescription(*input.Description)
	}
	if input.Status != nil {
		status := model.TaskStatus(*input.Status)
		if err := task.UpdateStatus(status); err != nil {
			return nil, goerr.Wrap(err, "failed to update task status")
		}
	}

	// Save updated task
	if err := r.repo.UpdateTask(ctx, task); err != nil {
		return nil, goerr.Wrap(err, "failed to save updated task", goerr.V("taskID", taskID))
	}

	return task, nil
}

// DeleteTask is the resolver for the deleteTask field.
func (r *mutationResolver) DeleteTask(ctx context.Context, id string) (bool, error) {
	// Parse task ID
	taskID := types.TaskID(id)

	// Check if task exists
	_, err := r.repo.GetTask(ctx, taskID)
	if err != nil {
		return false, goerr.Wrap(err, "failed to get task", goerr.V("taskID", taskID))
	}

	// Delete task
	if err := r.repo.DeleteTask(ctx, taskID); err != nil {
		return false, goerr.Wrap(err, "failed to delete task", goerr.V("taskID", taskID))
	}

	return true, nil
}

// Incidents is the resolver for the incidents field.
func (r *queryResolver) Incidents(ctx context.Context, first *int, after *string) (*graphql1.IncidentConnection, error) {
	// For now, return a simple implementation without proper pagination
	// TODO: Implement proper pagination with cursor-based pagination

	// Default limit
	_ = 20 // limit will be used when pagination is properly implemented
	if first != nil && *first > 0 && *first <= 100 {
		_ = *first
	}

	// Get all incidents from repository
	// TODO: Implement proper pagination with cursor-based pagination
	incidents, err := r.repo.ListIncidents(ctx)
	if err != nil {
		return nil, goerr.Wrap(err, "failed to list incidents")
	}

	// Apply pagination limit if specified
	if first != nil && *first > 0 && *first < len(incidents) {
		incidents = incidents[:*first]
	}

	// Create edges
	edges := make([]*graphql1.IncidentEdge, len(incidents))
	for i, incident := range incidents {
		edges[i] = &graphql1.IncidentEdge{
			Node:   incident,
			Cursor: fmt.Sprintf("%d", incident.ID),
		}
	}

	// Create page info
	pageInfo := &graphql1.PageInfo{
		HasNextPage:     false,
		HasPreviousPage: false,
		StartCursor:     nil,
		EndCursor:       nil,
	}

	if len(edges) > 0 {
		startCursor := edges[0].Cursor
		endCursor := edges[len(edges)-1].Cursor
		pageInfo.StartCursor = &startCursor
		pageInfo.EndCursor = &endCursor
	}

	return &graphql1.IncidentConnection{
		Edges:      edges,
		PageInfo:   pageInfo,
		TotalCount: len(incidents),
	}, nil
}

// Incident is the resolver for the incident field.
func (r *queryResolver) Incident(ctx context.Context, id string) (*model.Incident, error) {
	incidentID, err := strconv.ParseInt(id, 10, 64)
	if err != nil {
		return nil, goerr.Wrap(err, "invalid incident ID")
	}
	return r.repo.GetIncident(ctx, types.IncidentID(incidentID))
}

// Tasks is the resolver for the tasks field.
func (r *queryResolver) Tasks(ctx context.Context, incidentID string) ([]*model.Task, error) {
	id, err := strconv.ParseInt(incidentID, 10, 64)
	if err != nil {
		return nil, goerr.Wrap(err, "invalid incident ID")
	}
	return r.repo.ListTasksByIncident(ctx, types.IncidentID(id))
}

// Task is the resolver for the task field.
func (r *queryResolver) Task(ctx context.Context, id string) (*model.Task, error) {
	return r.repo.GetTask(ctx, types.TaskID(id))
}

// ID is the resolver for the id field.
func (r *taskResolver) ID(ctx context.Context, obj *model.Task) (string, error) {
	return string(obj.ID), nil
}

// IncidentID is the resolver for the incidentId field.
func (r *taskResolver) IncidentID(ctx context.Context, obj *model.Task) (string, error) {
	return fmt.Sprintf("%d", obj.IncidentID), nil
}

// AssigneeID is the resolver for the assigneeId field.
func (r *taskResolver) AssigneeID(ctx context.Context, obj *model.Task) (*string, error) {
	if obj.AssigneeID == "" {
		return nil, nil
	}
	assignee := string(obj.AssigneeID)
	return &assignee, nil
}

// CreatedBy is the resolver for the createdBy field.
func (r *taskResolver) CreatedBy(ctx context.Context, obj *model.Task) (string, error) {
	return string(obj.CreatedBy), nil
}

// ChannelID is the resolver for the channelId field.
func (r *taskResolver) ChannelID(ctx context.Context, obj *model.Task) (string, error) {
	return string(obj.ChannelID), nil
}

// ID is the resolver for the id field.
func (r *userResolver) ID(ctx context.Context, obj *model.User) (string, error) {
	return string(obj.ID), nil
}

// SlackUserID is the resolver for the slackUserId field.
func (r *userResolver) SlackUserID(ctx context.Context, obj *model.User) (string, error) {
	return string(obj.SlackUserID), nil
}

// Incident returns IncidentResolver implementation.
func (r *Resolver) Incident() IncidentResolver { return &incidentResolver{r} }

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

// Task returns TaskResolver implementation.
func (r *Resolver) Task() TaskResolver { return &taskResolver{r} }

// User returns UserResolver implementation.
func (r *Resolver) User() UserResolver { return &userResolver{r} }

type incidentResolver struct{ *Resolver }
type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type taskResolver struct{ *Resolver }
type userResolver struct{ *Resolver }
