// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mocks

import (
	"context"
	"github.com/secmon-lab/lycaon/pkg/domain/interfaces"
	"github.com/secmon-lab/lycaon/pkg/domain/model"
	"github.com/slack-go/slack/slackevents"
	"sync"
)

// Ensure, that SlackMessageMock does implement interfaces.SlackMessage.
// If this is not the case, regenerate this file with moq.
var _ interfaces.SlackMessage = &SlackMessageMock{}

// SlackMessageMock is a mock implementation of interfaces.SlackMessage.
//
//	func TestSomethingThatUsesSlackMessage(t *testing.T) {
//
//		// make and configure a mocked interfaces.SlackMessage
//		mockedSlackMessage := &SlackMessageMock{
//			GenerateResponseFunc: func(ctx context.Context, message *model.Message) (string, error) {
//				panic("mock out the GenerateResponse method")
//			},
//			IsBasicIncidentTriggerFunc: func(ctx context.Context, message *model.Message) bool {
//				panic("mock out the IsBasicIncidentTrigger method")
//			},
//			ParseIncidentCommandFunc: func(ctx context.Context, message *model.Message) interfaces.IncidentCommand {
//				panic("mock out the ParseIncidentCommand method")
//			},
//			ProcessMessageFunc: func(ctx context.Context, event *slackevents.MessageEvent) error {
//				panic("mock out the ProcessMessage method")
//			},
//			SaveAndRespondFunc: func(ctx context.Context, event *slackevents.MessageEvent) (string, error) {
//				panic("mock out the SaveAndRespond method")
//			},
//			SendIncidentMessageFunc: func(ctx context.Context, channelID string, messageTS string, title string, description string, categoryID string) error {
//				panic("mock out the SendIncidentMessage method")
//			},
//			SendProcessingMessageFunc: func(ctx context.Context, channelID string, messageTS string) error {
//				panic("mock out the SendProcessingMessage method")
//			},
//		}
//
//		// use mockedSlackMessage in code that requires interfaces.SlackMessage
//		// and then make assertions.
//
//	}
type SlackMessageMock struct {
	// GenerateResponseFunc mocks the GenerateResponse method.
	GenerateResponseFunc func(ctx context.Context, message *model.Message) (string, error)

	// IsBasicIncidentTriggerFunc mocks the IsBasicIncidentTrigger method.
	IsBasicIncidentTriggerFunc func(ctx context.Context, message *model.Message) bool

	// ParseIncidentCommandFunc mocks the ParseIncidentCommand method.
	ParseIncidentCommandFunc func(ctx context.Context, message *model.Message) interfaces.IncidentCommand

	// ProcessMessageFunc mocks the ProcessMessage method.
	ProcessMessageFunc func(ctx context.Context, event *slackevents.MessageEvent) error

	// SaveAndRespondFunc mocks the SaveAndRespond method.
	SaveAndRespondFunc func(ctx context.Context, event *slackevents.MessageEvent) (string, error)

	// SendIncidentMessageFunc mocks the SendIncidentMessage method.
	SendIncidentMessageFunc func(ctx context.Context, channelID string, messageTS string, title string, description string, categoryID string) error

	// SendProcessingMessageFunc mocks the SendProcessingMessage method.
	SendProcessingMessageFunc func(ctx context.Context, channelID string, messageTS string) error

	// calls tracks calls to the methods.
	calls struct {
		// GenerateResponse holds details about calls to the GenerateResponse method.
		GenerateResponse []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Message is the message argument value.
			Message *model.Message
		}
		// IsBasicIncidentTrigger holds details about calls to the IsBasicIncidentTrigger method.
		IsBasicIncidentTrigger []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Message is the message argument value.
			Message *model.Message
		}
		// ParseIncidentCommand holds details about calls to the ParseIncidentCommand method.
		ParseIncidentCommand []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Message is the message argument value.
			Message *model.Message
		}
		// ProcessMessage holds details about calls to the ProcessMessage method.
		ProcessMessage []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Event is the event argument value.
			Event *slackevents.MessageEvent
		}
		// SaveAndRespond holds details about calls to the SaveAndRespond method.
		SaveAndRespond []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Event is the event argument value.
			Event *slackevents.MessageEvent
		}
		// SendIncidentMessage holds details about calls to the SendIncidentMessage method.
		SendIncidentMessage []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ChannelID is the channelID argument value.
			ChannelID string
			// MessageTS is the messageTS argument value.
			MessageTS string
			// Title is the title argument value.
			Title string
			// Description is the description argument value.
			Description string
			// CategoryID is the categoryID argument value.
			CategoryID string
		}
		// SendProcessingMessage holds details about calls to the SendProcessingMessage method.
		SendProcessingMessage []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ChannelID is the channelID argument value.
			ChannelID string
			// MessageTS is the messageTS argument value.
			MessageTS string
		}
	}
	lockGenerateResponse       sync.RWMutex
	lockIsBasicIncidentTrigger sync.RWMutex
	lockParseIncidentCommand   sync.RWMutex
	lockProcessMessage         sync.RWMutex
	lockSaveAndRespond         sync.RWMutex
	lockSendIncidentMessage    sync.RWMutex
	lockSendProcessingMessage  sync.RWMutex
}

// GenerateResponse calls GenerateResponseFunc.
func (mock *SlackMessageMock) GenerateResponse(ctx context.Context, message *model.Message) (string, error) {
	if mock.GenerateResponseFunc == nil {
		panic("SlackMessageMock.GenerateResponseFunc: method is nil but SlackMessage.GenerateResponse was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Message *model.Message
	}{
		Ctx:     ctx,
		Message: message,
	}
	mock.lockGenerateResponse.Lock()
	mock.calls.GenerateResponse = append(mock.calls.GenerateResponse, callInfo)
	mock.lockGenerateResponse.Unlock()
	return mock.GenerateResponseFunc(ctx, message)
}

// GenerateResponseCalls gets all the calls that were made to GenerateResponse.
// Check the length with:
//
//	len(mockedSlackMessage.GenerateResponseCalls())
func (mock *SlackMessageMock) GenerateResponseCalls() []struct {
	Ctx     context.Context
	Message *model.Message
} {
	var calls []struct {
		Ctx     context.Context
		Message *model.Message
	}
	mock.lockGenerateResponse.RLock()
	calls = mock.calls.GenerateResponse
	mock.lockGenerateResponse.RUnlock()
	return calls
}

// IsBasicIncidentTrigger calls IsBasicIncidentTriggerFunc.
func (mock *SlackMessageMock) IsBasicIncidentTrigger(ctx context.Context, message *model.Message) bool {
	if mock.IsBasicIncidentTriggerFunc == nil {
		panic("SlackMessageMock.IsBasicIncidentTriggerFunc: method is nil but SlackMessage.IsBasicIncidentTrigger was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Message *model.Message
	}{
		Ctx:     ctx,
		Message: message,
	}
	mock.lockIsBasicIncidentTrigger.Lock()
	mock.calls.IsBasicIncidentTrigger = append(mock.calls.IsBasicIncidentTrigger, callInfo)
	mock.lockIsBasicIncidentTrigger.Unlock()
	return mock.IsBasicIncidentTriggerFunc(ctx, message)
}

// IsBasicIncidentTriggerCalls gets all the calls that were made to IsBasicIncidentTrigger.
// Check the length with:
//
//	len(mockedSlackMessage.IsBasicIncidentTriggerCalls())
func (mock *SlackMessageMock) IsBasicIncidentTriggerCalls() []struct {
	Ctx     context.Context
	Message *model.Message
} {
	var calls []struct {
		Ctx     context.Context
		Message *model.Message
	}
	mock.lockIsBasicIncidentTrigger.RLock()
	calls = mock.calls.IsBasicIncidentTrigger
	mock.lockIsBasicIncidentTrigger.RUnlock()
	return calls
}

// ParseIncidentCommand calls ParseIncidentCommandFunc.
func (mock *SlackMessageMock) ParseIncidentCommand(ctx context.Context, message *model.Message) interfaces.IncidentCommand {
	if mock.ParseIncidentCommandFunc == nil {
		panic("SlackMessageMock.ParseIncidentCommandFunc: method is nil but SlackMessage.ParseIncidentCommand was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Message *model.Message
	}{
		Ctx:     ctx,
		Message: message,
	}
	mock.lockParseIncidentCommand.Lock()
	mock.calls.ParseIncidentCommand = append(mock.calls.ParseIncidentCommand, callInfo)
	mock.lockParseIncidentCommand.Unlock()
	return mock.ParseIncidentCommandFunc(ctx, message)
}

// ParseIncidentCommandCalls gets all the calls that were made to ParseIncidentCommand.
// Check the length with:
//
//	len(mockedSlackMessage.ParseIncidentCommandCalls())
func (mock *SlackMessageMock) ParseIncidentCommandCalls() []struct {
	Ctx     context.Context
	Message *model.Message
} {
	var calls []struct {
		Ctx     context.Context
		Message *model.Message
	}
	mock.lockParseIncidentCommand.RLock()
	calls = mock.calls.ParseIncidentCommand
	mock.lockParseIncidentCommand.RUnlock()
	return calls
}

// ProcessMessage calls ProcessMessageFunc.
func (mock *SlackMessageMock) ProcessMessage(ctx context.Context, event *slackevents.MessageEvent) error {
	if mock.ProcessMessageFunc == nil {
		panic("SlackMessageMock.ProcessMessageFunc: method is nil but SlackMessage.ProcessMessage was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Event *slackevents.MessageEvent
	}{
		Ctx:   ctx,
		Event: event,
	}
	mock.lockProcessMessage.Lock()
	mock.calls.ProcessMessage = append(mock.calls.ProcessMessage, callInfo)
	mock.lockProcessMessage.Unlock()
	return mock.ProcessMessageFunc(ctx, event)
}

// ProcessMessageCalls gets all the calls that were made to ProcessMessage.
// Check the length with:
//
//	len(mockedSlackMessage.ProcessMessageCalls())
func (mock *SlackMessageMock) ProcessMessageCalls() []struct {
	Ctx   context.Context
	Event *slackevents.MessageEvent
} {
	var calls []struct {
		Ctx   context.Context
		Event *slackevents.MessageEvent
	}
	mock.lockProcessMessage.RLock()
	calls = mock.calls.ProcessMessage
	mock.lockProcessMessage.RUnlock()
	return calls
}

// SaveAndRespond calls SaveAndRespondFunc.
func (mock *SlackMessageMock) SaveAndRespond(ctx context.Context, event *slackevents.MessageEvent) (string, error) {
	if mock.SaveAndRespondFunc == nil {
		panic("SlackMessageMock.SaveAndRespondFunc: method is nil but SlackMessage.SaveAndRespond was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Event *slackevents.MessageEvent
	}{
		Ctx:   ctx,
		Event: event,
	}
	mock.lockSaveAndRespond.Lock()
	mock.calls.SaveAndRespond = append(mock.calls.SaveAndRespond, callInfo)
	mock.lockSaveAndRespond.Unlock()
	return mock.SaveAndRespondFunc(ctx, event)
}

// SaveAndRespondCalls gets all the calls that were made to SaveAndRespond.
// Check the length with:
//
//	len(mockedSlackMessage.SaveAndRespondCalls())
func (mock *SlackMessageMock) SaveAndRespondCalls() []struct {
	Ctx   context.Context
	Event *slackevents.MessageEvent
} {
	var calls []struct {
		Ctx   context.Context
		Event *slackevents.MessageEvent
	}
	mock.lockSaveAndRespond.RLock()
	calls = mock.calls.SaveAndRespond
	mock.lockSaveAndRespond.RUnlock()
	return calls
}

// SendIncidentMessage calls SendIncidentMessageFunc.
func (mock *SlackMessageMock) SendIncidentMessage(ctx context.Context, channelID string, messageTS string, title string, description string, categoryID string) error {
	if mock.SendIncidentMessageFunc == nil {
		panic("SlackMessageMock.SendIncidentMessageFunc: method is nil but SlackMessage.SendIncidentMessage was just called")
	}
	callInfo := struct {
		Ctx         context.Context
		ChannelID   string
		MessageTS   string
		Title       string
		Description string
		CategoryID  string
	}{
		Ctx:         ctx,
		ChannelID:   channelID,
		MessageTS:   messageTS,
		Title:       title,
		Description: description,
		CategoryID:  categoryID,
	}
	mock.lockSendIncidentMessage.Lock()
	mock.calls.SendIncidentMessage = append(mock.calls.SendIncidentMessage, callInfo)
	mock.lockSendIncidentMessage.Unlock()
	return mock.SendIncidentMessageFunc(ctx, channelID, messageTS, title, description, categoryID)
}

// SendIncidentMessageCalls gets all the calls that were made to SendIncidentMessage.
// Check the length with:
//
//	len(mockedSlackMessage.SendIncidentMessageCalls())
func (mock *SlackMessageMock) SendIncidentMessageCalls() []struct {
	Ctx         context.Context
	ChannelID   string
	MessageTS   string
	Title       string
	Description string
	CategoryID  string
} {
	var calls []struct {
		Ctx         context.Context
		ChannelID   string
		MessageTS   string
		Title       string
		Description string
		CategoryID  string
	}
	mock.lockSendIncidentMessage.RLock()
	calls = mock.calls.SendIncidentMessage
	mock.lockSendIncidentMessage.RUnlock()
	return calls
}

// SendProcessingMessage calls SendProcessingMessageFunc.
func (mock *SlackMessageMock) SendProcessingMessage(ctx context.Context, channelID string, messageTS string) error {
	if mock.SendProcessingMessageFunc == nil {
		panic("SlackMessageMock.SendProcessingMessageFunc: method is nil but SlackMessage.SendProcessingMessage was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		ChannelID string
		MessageTS string
	}{
		Ctx:       ctx,
		ChannelID: channelID,
		MessageTS: messageTS,
	}
	mock.lockSendProcessingMessage.Lock()
	mock.calls.SendProcessingMessage = append(mock.calls.SendProcessingMessage, callInfo)
	mock.lockSendProcessingMessage.Unlock()
	return mock.SendProcessingMessageFunc(ctx, channelID, messageTS)
}

// SendProcessingMessageCalls gets all the calls that were made to SendProcessingMessage.
// Check the length with:
//
//	len(mockedSlackMessage.SendProcessingMessageCalls())
func (mock *SlackMessageMock) SendProcessingMessageCalls() []struct {
	Ctx       context.Context
	ChannelID string
	MessageTS string
} {
	var calls []struct {
		Ctx       context.Context
		ChannelID string
		MessageTS string
	}
	mock.lockSendProcessingMessage.RLock()
	calls = mock.calls.SendProcessingMessage
	mock.lockSendProcessingMessage.RUnlock()
	return calls
}

// Ensure, that IncidentMock does implement interfaces.Incident.
// If this is not the case, regenerate this file with moq.
var _ interfaces.Incident = &IncidentMock{}

// IncidentMock is a mock implementation of interfaces.Incident.
//
//	func TestSomethingThatUsesIncident(t *testing.T) {
//
//		// make and configure a mocked interfaces.Incident
//		mockedIncident := &IncidentMock{
//			CreateIncidentFunc: func(ctx context.Context, req *model.CreateIncidentRequest) (*model.Incident, error) {
//				panic("mock out the CreateIncident method")
//			},
//			CreateIncidentFromInteractionFunc: func(ctx context.Context, originChannelID string, title string, userID string) (*model.Incident, error) {
//				panic("mock out the CreateIncidentFromInteraction method")
//			},
//			GetIncidentFunc: func(ctx context.Context, id int) (*model.Incident, error) {
//				panic("mock out the GetIncident method")
//			},
//			GetIncidentRequestFunc: func(ctx context.Context, requestID string) (*model.IncidentRequest, error) {
//				panic("mock out the GetIncidentRequest method")
//			},
//			HandleCreateIncidentActionFunc: func(ctx context.Context, requestID string, userID string) (*model.Incident, error) {
//				panic("mock out the HandleCreateIncidentAction method")
//			},
//			HandleCreateIncidentActionAsyncFunc: func(ctx context.Context, requestID string, userID string, channelID string)  {
//				panic("mock out the HandleCreateIncidentActionAsync method")
//			},
//			HandleCreateIncidentWithDetailsFunc: func(ctx context.Context, requestID string, title string, description string, categoryID string, userID string) (*model.Incident, error) {
//				panic("mock out the HandleCreateIncidentWithDetails method")
//			},
//			HandleEditIncidentActionFunc: func(ctx context.Context, requestID string, userID string, triggerID string) error {
//				panic("mock out the HandleEditIncidentAction method")
//			},
//		}
//
//		// use mockedIncident in code that requires interfaces.Incident
//		// and then make assertions.
//
//	}
type IncidentMock struct {
	// CreateIncidentFunc mocks the CreateIncident method.
	CreateIncidentFunc func(ctx context.Context, req *model.CreateIncidentRequest) (*model.Incident, error)

	// CreateIncidentFromInteractionFunc mocks the CreateIncidentFromInteraction method.
	CreateIncidentFromInteractionFunc func(ctx context.Context, originChannelID string, title string, userID string) (*model.Incident, error)

	// GetIncidentFunc mocks the GetIncident method.
	GetIncidentFunc func(ctx context.Context, id int) (*model.Incident, error)

	// GetIncidentRequestFunc mocks the GetIncidentRequest method.
	GetIncidentRequestFunc func(ctx context.Context, requestID string) (*model.IncidentRequest, error)

	// HandleCreateIncidentActionFunc mocks the HandleCreateIncidentAction method.
	HandleCreateIncidentActionFunc func(ctx context.Context, requestID string, userID string) (*model.Incident, error)

	// HandleCreateIncidentActionAsyncFunc mocks the HandleCreateIncidentActionAsync method.
	HandleCreateIncidentActionAsyncFunc func(ctx context.Context, requestID string, userID string, channelID string)

	// HandleCreateIncidentWithDetailsFunc mocks the HandleCreateIncidentWithDetails method.
	HandleCreateIncidentWithDetailsFunc func(ctx context.Context, requestID string, title string, description string, categoryID string, userID string) (*model.Incident, error)

	// HandleEditIncidentActionFunc mocks the HandleEditIncidentAction method.
	HandleEditIncidentActionFunc func(ctx context.Context, requestID string, userID string, triggerID string) error

	// calls tracks calls to the methods.
	calls struct {
		// CreateIncident holds details about calls to the CreateIncident method.
		CreateIncident []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Req is the req argument value.
			Req *model.CreateIncidentRequest
		}
		// CreateIncidentFromInteraction holds details about calls to the CreateIncidentFromInteraction method.
		CreateIncidentFromInteraction []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// OriginChannelID is the originChannelID argument value.
			OriginChannelID string
			// Title is the title argument value.
			Title string
			// UserID is the userID argument value.
			UserID string
		}
		// GetIncident holds details about calls to the GetIncident method.
		GetIncident []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID int
		}
		// GetIncidentRequest holds details about calls to the GetIncidentRequest method.
		GetIncidentRequest []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// RequestID is the requestID argument value.
			RequestID string
		}
		// HandleCreateIncidentAction holds details about calls to the HandleCreateIncidentAction method.
		HandleCreateIncidentAction []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// RequestID is the requestID argument value.
			RequestID string
			// UserID is the userID argument value.
			UserID string
		}
		// HandleCreateIncidentActionAsync holds details about calls to the HandleCreateIncidentActionAsync method.
		HandleCreateIncidentActionAsync []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// RequestID is the requestID argument value.
			RequestID string
			// UserID is the userID argument value.
			UserID string
			// ChannelID is the channelID argument value.
			ChannelID string
		}
		// HandleCreateIncidentWithDetails holds details about calls to the HandleCreateIncidentWithDetails method.
		HandleCreateIncidentWithDetails []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// RequestID is the requestID argument value.
			RequestID string
			// Title is the title argument value.
			Title string
			// Description is the description argument value.
			Description string
			// CategoryID is the categoryID argument value.
			CategoryID string
			// UserID is the userID argument value.
			UserID string
		}
		// HandleEditIncidentAction holds details about calls to the HandleEditIncidentAction method.
		HandleEditIncidentAction []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// RequestID is the requestID argument value.
			RequestID string
			// UserID is the userID argument value.
			UserID string
			// TriggerID is the triggerID argument value.
			TriggerID string
		}
	}
	lockCreateIncident                  sync.RWMutex
	lockCreateIncidentFromInteraction   sync.RWMutex
	lockGetIncident                     sync.RWMutex
	lockGetIncidentRequest              sync.RWMutex
	lockHandleCreateIncidentAction      sync.RWMutex
	lockHandleCreateIncidentActionAsync sync.RWMutex
	lockHandleCreateIncidentWithDetails sync.RWMutex
	lockHandleEditIncidentAction        sync.RWMutex
}

// CreateIncident calls CreateIncidentFunc.
func (mock *IncidentMock) CreateIncident(ctx context.Context, req *model.CreateIncidentRequest) (*model.Incident, error) {
	if mock.CreateIncidentFunc == nil {
		panic("IncidentMock.CreateIncidentFunc: method is nil but Incident.CreateIncident was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Req *model.CreateIncidentRequest
	}{
		Ctx: ctx,
		Req: req,
	}
	mock.lockCreateIncident.Lock()
	mock.calls.CreateIncident = append(mock.calls.CreateIncident, callInfo)
	mock.lockCreateIncident.Unlock()
	return mock.CreateIncidentFunc(ctx, req)
}

// CreateIncidentCalls gets all the calls that were made to CreateIncident.
// Check the length with:
//
//	len(mockedIncident.CreateIncidentCalls())
func (mock *IncidentMock) CreateIncidentCalls() []struct {
	Ctx context.Context
	Req *model.CreateIncidentRequest
} {
	var calls []struct {
		Ctx context.Context
		Req *model.CreateIncidentRequest
	}
	mock.lockCreateIncident.RLock()
	calls = mock.calls.CreateIncident
	mock.lockCreateIncident.RUnlock()
	return calls
}

// CreateIncidentFromInteraction calls CreateIncidentFromInteractionFunc.
func (mock *IncidentMock) CreateIncidentFromInteraction(ctx context.Context, originChannelID string, title string, userID string) (*model.Incident, error) {
	if mock.CreateIncidentFromInteractionFunc == nil {
		panic("IncidentMock.CreateIncidentFromInteractionFunc: method is nil but Incident.CreateIncidentFromInteraction was just called")
	}
	callInfo := struct {
		Ctx             context.Context
		OriginChannelID string
		Title           string
		UserID          string
	}{
		Ctx:             ctx,
		OriginChannelID: originChannelID,
		Title:           title,
		UserID:          userID,
	}
	mock.lockCreateIncidentFromInteraction.Lock()
	mock.calls.CreateIncidentFromInteraction = append(mock.calls.CreateIncidentFromInteraction, callInfo)
	mock.lockCreateIncidentFromInteraction.Unlock()
	return mock.CreateIncidentFromInteractionFunc(ctx, originChannelID, title, userID)
}

// CreateIncidentFromInteractionCalls gets all the calls that were made to CreateIncidentFromInteraction.
// Check the length with:
//
//	len(mockedIncident.CreateIncidentFromInteractionCalls())
func (mock *IncidentMock) CreateIncidentFromInteractionCalls() []struct {
	Ctx             context.Context
	OriginChannelID string
	Title           string
	UserID          string
} {
	var calls []struct {
		Ctx             context.Context
		OriginChannelID string
		Title           string
		UserID          string
	}
	mock.lockCreateIncidentFromInteraction.RLock()
	calls = mock.calls.CreateIncidentFromInteraction
	mock.lockCreateIncidentFromInteraction.RUnlock()
	return calls
}

// GetIncident calls GetIncidentFunc.
func (mock *IncidentMock) GetIncident(ctx context.Context, id int) (*model.Incident, error) {
	if mock.GetIncidentFunc == nil {
		panic("IncidentMock.GetIncidentFunc: method is nil but Incident.GetIncident was just called")
	}
	callInfo := struct {
		Ctx context.Context
		ID  int
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockGetIncident.Lock()
	mock.calls.GetIncident = append(mock.calls.GetIncident, callInfo)
	mock.lockGetIncident.Unlock()
	return mock.GetIncidentFunc(ctx, id)
}

// GetIncidentCalls gets all the calls that were made to GetIncident.
// Check the length with:
//
//	len(mockedIncident.GetIncidentCalls())
func (mock *IncidentMock) GetIncidentCalls() []struct {
	Ctx context.Context
	ID  int
} {
	var calls []struct {
		Ctx context.Context
		ID  int
	}
	mock.lockGetIncident.RLock()
	calls = mock.calls.GetIncident
	mock.lockGetIncident.RUnlock()
	return calls
}

// GetIncidentRequest calls GetIncidentRequestFunc.
func (mock *IncidentMock) GetIncidentRequest(ctx context.Context, requestID string) (*model.IncidentRequest, error) {
	if mock.GetIncidentRequestFunc == nil {
		panic("IncidentMock.GetIncidentRequestFunc: method is nil but Incident.GetIncidentRequest was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		RequestID string
	}{
		Ctx:       ctx,
		RequestID: requestID,
	}
	mock.lockGetIncidentRequest.Lock()
	mock.calls.GetIncidentRequest = append(mock.calls.GetIncidentRequest, callInfo)
	mock.lockGetIncidentRequest.Unlock()
	return mock.GetIncidentRequestFunc(ctx, requestID)
}

// GetIncidentRequestCalls gets all the calls that were made to GetIncidentRequest.
// Check the length with:
//
//	len(mockedIncident.GetIncidentRequestCalls())
func (mock *IncidentMock) GetIncidentRequestCalls() []struct {
	Ctx       context.Context
	RequestID string
} {
	var calls []struct {
		Ctx       context.Context
		RequestID string
	}
	mock.lockGetIncidentRequest.RLock()
	calls = mock.calls.GetIncidentRequest
	mock.lockGetIncidentRequest.RUnlock()
	return calls
}

// HandleCreateIncidentAction calls HandleCreateIncidentActionFunc.
func (mock *IncidentMock) HandleCreateIncidentAction(ctx context.Context, requestID string, userID string) (*model.Incident, error) {
	if mock.HandleCreateIncidentActionFunc == nil {
		panic("IncidentMock.HandleCreateIncidentActionFunc: method is nil but Incident.HandleCreateIncidentAction was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		RequestID string
		UserID    string
	}{
		Ctx:       ctx,
		RequestID: requestID,
		UserID:    userID,
	}
	mock.lockHandleCreateIncidentAction.Lock()
	mock.calls.HandleCreateIncidentAction = append(mock.calls.HandleCreateIncidentAction, callInfo)
	mock.lockHandleCreateIncidentAction.Unlock()
	return mock.HandleCreateIncidentActionFunc(ctx, requestID, userID)
}

// HandleCreateIncidentActionCalls gets all the calls that were made to HandleCreateIncidentAction.
// Check the length with:
//
//	len(mockedIncident.HandleCreateIncidentActionCalls())
func (mock *IncidentMock) HandleCreateIncidentActionCalls() []struct {
	Ctx       context.Context
	RequestID string
	UserID    string
} {
	var calls []struct {
		Ctx       context.Context
		RequestID string
		UserID    string
	}
	mock.lockHandleCreateIncidentAction.RLock()
	calls = mock.calls.HandleCreateIncidentAction
	mock.lockHandleCreateIncidentAction.RUnlock()
	return calls
}

// HandleCreateIncidentActionAsync calls HandleCreateIncidentActionAsyncFunc.
func (mock *IncidentMock) HandleCreateIncidentActionAsync(ctx context.Context, requestID string, userID string, channelID string) {
	if mock.HandleCreateIncidentActionAsyncFunc == nil {
		panic("IncidentMock.HandleCreateIncidentActionAsyncFunc: method is nil but Incident.HandleCreateIncidentActionAsync was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		RequestID string
		UserID    string
		ChannelID string
	}{
		Ctx:       ctx,
		RequestID: requestID,
		UserID:    userID,
		ChannelID: channelID,
	}
	mock.lockHandleCreateIncidentActionAsync.Lock()
	mock.calls.HandleCreateIncidentActionAsync = append(mock.calls.HandleCreateIncidentActionAsync, callInfo)
	mock.lockHandleCreateIncidentActionAsync.Unlock()
	mock.HandleCreateIncidentActionAsyncFunc(ctx, requestID, userID, channelID)
}

// HandleCreateIncidentActionAsyncCalls gets all the calls that were made to HandleCreateIncidentActionAsync.
// Check the length with:
//
//	len(mockedIncident.HandleCreateIncidentActionAsyncCalls())
func (mock *IncidentMock) HandleCreateIncidentActionAsyncCalls() []struct {
	Ctx       context.Context
	RequestID string
	UserID    string
	ChannelID string
} {
	var calls []struct {
		Ctx       context.Context
		RequestID string
		UserID    string
		ChannelID string
	}
	mock.lockHandleCreateIncidentActionAsync.RLock()
	calls = mock.calls.HandleCreateIncidentActionAsync
	mock.lockHandleCreateIncidentActionAsync.RUnlock()
	return calls
}

// HandleCreateIncidentWithDetails calls HandleCreateIncidentWithDetailsFunc.
func (mock *IncidentMock) HandleCreateIncidentWithDetails(ctx context.Context, requestID string, title string, description string, categoryID string, userID string) (*model.Incident, error) {
	if mock.HandleCreateIncidentWithDetailsFunc == nil {
		panic("IncidentMock.HandleCreateIncidentWithDetailsFunc: method is nil but Incident.HandleCreateIncidentWithDetails was just called")
	}
	callInfo := struct {
		Ctx         context.Context
		RequestID   string
		Title       string
		Description string
		CategoryID  string
		UserID      string
	}{
		Ctx:         ctx,
		RequestID:   requestID,
		Title:       title,
		Description: description,
		CategoryID:  categoryID,
		UserID:      userID,
	}
	mock.lockHandleCreateIncidentWithDetails.Lock()
	mock.calls.HandleCreateIncidentWithDetails = append(mock.calls.HandleCreateIncidentWithDetails, callInfo)
	mock.lockHandleCreateIncidentWithDetails.Unlock()
	return mock.HandleCreateIncidentWithDetailsFunc(ctx, requestID, title, description, categoryID, userID)
}

// HandleCreateIncidentWithDetailsCalls gets all the calls that were made to HandleCreateIncidentWithDetails.
// Check the length with:
//
//	len(mockedIncident.HandleCreateIncidentWithDetailsCalls())
func (mock *IncidentMock) HandleCreateIncidentWithDetailsCalls() []struct {
	Ctx         context.Context
	RequestID   string
	Title       string
	Description string
	CategoryID  string
	UserID      string
} {
	var calls []struct {
		Ctx         context.Context
		RequestID   string
		Title       string
		Description string
		CategoryID  string
		UserID      string
	}
	mock.lockHandleCreateIncidentWithDetails.RLock()
	calls = mock.calls.HandleCreateIncidentWithDetails
	mock.lockHandleCreateIncidentWithDetails.RUnlock()
	return calls
}

// HandleEditIncidentAction calls HandleEditIncidentActionFunc.
func (mock *IncidentMock) HandleEditIncidentAction(ctx context.Context, requestID string, userID string, triggerID string) error {
	if mock.HandleEditIncidentActionFunc == nil {
		panic("IncidentMock.HandleEditIncidentActionFunc: method is nil but Incident.HandleEditIncidentAction was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		RequestID string
		UserID    string
		TriggerID string
	}{
		Ctx:       ctx,
		RequestID: requestID,
		UserID:    userID,
		TriggerID: triggerID,
	}
	mock.lockHandleEditIncidentAction.Lock()
	mock.calls.HandleEditIncidentAction = append(mock.calls.HandleEditIncidentAction, callInfo)
	mock.lockHandleEditIncidentAction.Unlock()
	return mock.HandleEditIncidentActionFunc(ctx, requestID, userID, triggerID)
}

// HandleEditIncidentActionCalls gets all the calls that were made to HandleEditIncidentAction.
// Check the length with:
//
//	len(mockedIncident.HandleEditIncidentActionCalls())
func (mock *IncidentMock) HandleEditIncidentActionCalls() []struct {
	Ctx       context.Context
	RequestID string
	UserID    string
	TriggerID string
} {
	var calls []struct {
		Ctx       context.Context
		RequestID string
		UserID    string
		TriggerID string
	}
	mock.lockHandleEditIncidentAction.RLock()
	calls = mock.calls.HandleEditIncidentAction
	mock.lockHandleEditIncidentAction.RUnlock()
	return calls
}
