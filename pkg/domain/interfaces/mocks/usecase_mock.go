// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mocks

import (
	"context"
	"github.com/secmon-lab/lycaon/pkg/domain/interfaces"
	"github.com/secmon-lab/lycaon/pkg/domain/model"
	"github.com/secmon-lab/lycaon/pkg/domain/types"
	"github.com/slack-go/slack/slackevents"
	"sync"
)

// Ensure, that SlackMessageMock does implement interfaces.SlackMessage.
// If this is not the case, regenerate this file with moq.
var _ interfaces.SlackMessage = &SlackMessageMock{}

// SlackMessageMock is a mock implementation of interfaces.SlackMessage.
//
//	func TestSomethingThatUsesSlackMessage(t *testing.T) {
//
//		// make and configure a mocked interfaces.SlackMessage
//		mockedSlackMessage := &SlackMessageMock{
//			GenerateResponseFunc: func(ctx context.Context, message *model.Message) (string, error) {
//				panic("mock out the GenerateResponse method")
//			},
//			IsBasicIncidentTriggerFunc: func(ctx context.Context, message *model.Message) bool {
//				panic("mock out the IsBasicIncidentTrigger method")
//			},
//			ParseIncidentCommandFunc: func(ctx context.Context, message *model.Message) interfaces.IncidentCommand {
//				panic("mock out the ParseIncidentCommand method")
//			},
//			ProcessMessageFunc: func(ctx context.Context, event *slackevents.MessageEvent) error {
//				panic("mock out the ProcessMessage method")
//			},
//			SaveAndRespondFunc: func(ctx context.Context, event *slackevents.MessageEvent) (string, error) {
//				panic("mock out the SaveAndRespond method")
//			},
//			SendIncidentMessageFunc: func(ctx context.Context, channelID string, messageTS string, title string, description string, categoryID string) error {
//				panic("mock out the SendIncidentMessage method")
//			},
//			SendProcessingMessageFunc: func(ctx context.Context, channelID string, messageTS string) error {
//				panic("mock out the SendProcessingMessage method")
//			},
//		}
//
//		// use mockedSlackMessage in code that requires interfaces.SlackMessage
//		// and then make assertions.
//
//	}
type SlackMessageMock struct {
	// GenerateResponseFunc mocks the GenerateResponse method.
	GenerateResponseFunc func(ctx context.Context, message *model.Message) (string, error)

	// IsBasicIncidentTriggerFunc mocks the IsBasicIncidentTrigger method.
	IsBasicIncidentTriggerFunc func(ctx context.Context, message *model.Message) bool

	// ParseIncidentCommandFunc mocks the ParseIncidentCommand method.
	ParseIncidentCommandFunc func(ctx context.Context, message *model.Message) interfaces.IncidentCommand

	// ProcessMessageFunc mocks the ProcessMessage method.
	ProcessMessageFunc func(ctx context.Context, event *slackevents.MessageEvent) error

	// SaveAndRespondFunc mocks the SaveAndRespond method.
	SaveAndRespondFunc func(ctx context.Context, event *slackevents.MessageEvent) (string, error)

	// SendIncidentMessageFunc mocks the SendIncidentMessage method.
	SendIncidentMessageFunc func(ctx context.Context, channelID string, messageTS string, title string, description string, categoryID string) error

	// SendProcessingMessageFunc mocks the SendProcessingMessage method.
	SendProcessingMessageFunc func(ctx context.Context, channelID string, messageTS string) error

	// calls tracks calls to the methods.
	calls struct {
		// GenerateResponse holds details about calls to the GenerateResponse method.
		GenerateResponse []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Message is the message argument value.
			Message *model.Message
		}
		// IsBasicIncidentTrigger holds details about calls to the IsBasicIncidentTrigger method.
		IsBasicIncidentTrigger []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Message is the message argument value.
			Message *model.Message
		}
		// ParseIncidentCommand holds details about calls to the ParseIncidentCommand method.
		ParseIncidentCommand []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Message is the message argument value.
			Message *model.Message
		}
		// ProcessMessage holds details about calls to the ProcessMessage method.
		ProcessMessage []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Event is the event argument value.
			Event *slackevents.MessageEvent
		}
		// SaveAndRespond holds details about calls to the SaveAndRespond method.
		SaveAndRespond []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Event is the event argument value.
			Event *slackevents.MessageEvent
		}
		// SendIncidentMessage holds details about calls to the SendIncidentMessage method.
		SendIncidentMessage []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ChannelID is the channelID argument value.
			ChannelID string
			// MessageTS is the messageTS argument value.
			MessageTS string
			// Title is the title argument value.
			Title string
			// Description is the description argument value.
			Description string
			// CategoryID is the categoryID argument value.
			CategoryID string
		}
		// SendProcessingMessage holds details about calls to the SendProcessingMessage method.
		SendProcessingMessage []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ChannelID is the channelID argument value.
			ChannelID string
			// MessageTS is the messageTS argument value.
			MessageTS string
		}
	}
	lockGenerateResponse       sync.RWMutex
	lockIsBasicIncidentTrigger sync.RWMutex
	lockParseIncidentCommand   sync.RWMutex
	lockProcessMessage         sync.RWMutex
	lockSaveAndRespond         sync.RWMutex
	lockSendIncidentMessage    sync.RWMutex
	lockSendProcessingMessage  sync.RWMutex
}

// GenerateResponse calls GenerateResponseFunc.
func (mock *SlackMessageMock) GenerateResponse(ctx context.Context, message *model.Message) (string, error) {
	if mock.GenerateResponseFunc == nil {
		panic("SlackMessageMock.GenerateResponseFunc: method is nil but SlackMessage.GenerateResponse was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Message *model.Message
	}{
		Ctx:     ctx,
		Message: message,
	}
	mock.lockGenerateResponse.Lock()
	mock.calls.GenerateResponse = append(mock.calls.GenerateResponse, callInfo)
	mock.lockGenerateResponse.Unlock()
	return mock.GenerateResponseFunc(ctx, message)
}

// GenerateResponseCalls gets all the calls that were made to GenerateResponse.
// Check the length with:
//
//	len(mockedSlackMessage.GenerateResponseCalls())
func (mock *SlackMessageMock) GenerateResponseCalls() []struct {
	Ctx     context.Context
	Message *model.Message
} {
	var calls []struct {
		Ctx     context.Context
		Message *model.Message
	}
	mock.lockGenerateResponse.RLock()
	calls = mock.calls.GenerateResponse
	mock.lockGenerateResponse.RUnlock()
	return calls
}

// IsBasicIncidentTrigger calls IsBasicIncidentTriggerFunc.
func (mock *SlackMessageMock) IsBasicIncidentTrigger(ctx context.Context, message *model.Message) bool {
	if mock.IsBasicIncidentTriggerFunc == nil {
		panic("SlackMessageMock.IsBasicIncidentTriggerFunc: method is nil but SlackMessage.IsBasicIncidentTrigger was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Message *model.Message
	}{
		Ctx:     ctx,
		Message: message,
	}
	mock.lockIsBasicIncidentTrigger.Lock()
	mock.calls.IsBasicIncidentTrigger = append(mock.calls.IsBasicIncidentTrigger, callInfo)
	mock.lockIsBasicIncidentTrigger.Unlock()
	return mock.IsBasicIncidentTriggerFunc(ctx, message)
}

// IsBasicIncidentTriggerCalls gets all the calls that were made to IsBasicIncidentTrigger.
// Check the length with:
//
//	len(mockedSlackMessage.IsBasicIncidentTriggerCalls())
func (mock *SlackMessageMock) IsBasicIncidentTriggerCalls() []struct {
	Ctx     context.Context
	Message *model.Message
} {
	var calls []struct {
		Ctx     context.Context
		Message *model.Message
	}
	mock.lockIsBasicIncidentTrigger.RLock()
	calls = mock.calls.IsBasicIncidentTrigger
	mock.lockIsBasicIncidentTrigger.RUnlock()
	return calls
}

// ParseIncidentCommand calls ParseIncidentCommandFunc.
func (mock *SlackMessageMock) ParseIncidentCommand(ctx context.Context, message *model.Message) interfaces.IncidentCommand {
	if mock.ParseIncidentCommandFunc == nil {
		panic("SlackMessageMock.ParseIncidentCommandFunc: method is nil but SlackMessage.ParseIncidentCommand was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Message *model.Message
	}{
		Ctx:     ctx,
		Message: message,
	}
	mock.lockParseIncidentCommand.Lock()
	mock.calls.ParseIncidentCommand = append(mock.calls.ParseIncidentCommand, callInfo)
	mock.lockParseIncidentCommand.Unlock()
	return mock.ParseIncidentCommandFunc(ctx, message)
}

// ParseIncidentCommandCalls gets all the calls that were made to ParseIncidentCommand.
// Check the length with:
//
//	len(mockedSlackMessage.ParseIncidentCommandCalls())
func (mock *SlackMessageMock) ParseIncidentCommandCalls() []struct {
	Ctx     context.Context
	Message *model.Message
} {
	var calls []struct {
		Ctx     context.Context
		Message *model.Message
	}
	mock.lockParseIncidentCommand.RLock()
	calls = mock.calls.ParseIncidentCommand
	mock.lockParseIncidentCommand.RUnlock()
	return calls
}

// ProcessMessage calls ProcessMessageFunc.
func (mock *SlackMessageMock) ProcessMessage(ctx context.Context, event *slackevents.MessageEvent) error {
	if mock.ProcessMessageFunc == nil {
		panic("SlackMessageMock.ProcessMessageFunc: method is nil but SlackMessage.ProcessMessage was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Event *slackevents.MessageEvent
	}{
		Ctx:   ctx,
		Event: event,
	}
	mock.lockProcessMessage.Lock()
	mock.calls.ProcessMessage = append(mock.calls.ProcessMessage, callInfo)
	mock.lockProcessMessage.Unlock()
	return mock.ProcessMessageFunc(ctx, event)
}

// ProcessMessageCalls gets all the calls that were made to ProcessMessage.
// Check the length with:
//
//	len(mockedSlackMessage.ProcessMessageCalls())
func (mock *SlackMessageMock) ProcessMessageCalls() []struct {
	Ctx   context.Context
	Event *slackevents.MessageEvent
} {
	var calls []struct {
		Ctx   context.Context
		Event *slackevents.MessageEvent
	}
	mock.lockProcessMessage.RLock()
	calls = mock.calls.ProcessMessage
	mock.lockProcessMessage.RUnlock()
	return calls
}

// SaveAndRespond calls SaveAndRespondFunc.
func (mock *SlackMessageMock) SaveAndRespond(ctx context.Context, event *slackevents.MessageEvent) (string, error) {
	if mock.SaveAndRespondFunc == nil {
		panic("SlackMessageMock.SaveAndRespondFunc: method is nil but SlackMessage.SaveAndRespond was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Event *slackevents.MessageEvent
	}{
		Ctx:   ctx,
		Event: event,
	}
	mock.lockSaveAndRespond.Lock()
	mock.calls.SaveAndRespond = append(mock.calls.SaveAndRespond, callInfo)
	mock.lockSaveAndRespond.Unlock()
	return mock.SaveAndRespondFunc(ctx, event)
}

// SaveAndRespondCalls gets all the calls that were made to SaveAndRespond.
// Check the length with:
//
//	len(mockedSlackMessage.SaveAndRespondCalls())
func (mock *SlackMessageMock) SaveAndRespondCalls() []struct {
	Ctx   context.Context
	Event *slackevents.MessageEvent
} {
	var calls []struct {
		Ctx   context.Context
		Event *slackevents.MessageEvent
	}
	mock.lockSaveAndRespond.RLock()
	calls = mock.calls.SaveAndRespond
	mock.lockSaveAndRespond.RUnlock()
	return calls
}

// SendIncidentMessage calls SendIncidentMessageFunc.
func (mock *SlackMessageMock) SendIncidentMessage(ctx context.Context, channelID string, messageTS string, title string, description string, categoryID string) error {
	if mock.SendIncidentMessageFunc == nil {
		panic("SlackMessageMock.SendIncidentMessageFunc: method is nil but SlackMessage.SendIncidentMessage was just called")
	}
	callInfo := struct {
		Ctx         context.Context
		ChannelID   string
		MessageTS   string
		Title       string
		Description string
		CategoryID  string
	}{
		Ctx:         ctx,
		ChannelID:   channelID,
		MessageTS:   messageTS,
		Title:       title,
		Description: description,
		CategoryID:  categoryID,
	}
	mock.lockSendIncidentMessage.Lock()
	mock.calls.SendIncidentMessage = append(mock.calls.SendIncidentMessage, callInfo)
	mock.lockSendIncidentMessage.Unlock()
	return mock.SendIncidentMessageFunc(ctx, channelID, messageTS, title, description, categoryID)
}

// SendIncidentMessageCalls gets all the calls that were made to SendIncidentMessage.
// Check the length with:
//
//	len(mockedSlackMessage.SendIncidentMessageCalls())
func (mock *SlackMessageMock) SendIncidentMessageCalls() []struct {
	Ctx         context.Context
	ChannelID   string
	MessageTS   string
	Title       string
	Description string
	CategoryID  string
} {
	var calls []struct {
		Ctx         context.Context
		ChannelID   string
		MessageTS   string
		Title       string
		Description string
		CategoryID  string
	}
	mock.lockSendIncidentMessage.RLock()
	calls = mock.calls.SendIncidentMessage
	mock.lockSendIncidentMessage.RUnlock()
	return calls
}

// SendProcessingMessage calls SendProcessingMessageFunc.
func (mock *SlackMessageMock) SendProcessingMessage(ctx context.Context, channelID string, messageTS string) error {
	if mock.SendProcessingMessageFunc == nil {
		panic("SlackMessageMock.SendProcessingMessageFunc: method is nil but SlackMessage.SendProcessingMessage was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		ChannelID string
		MessageTS string
	}{
		Ctx:       ctx,
		ChannelID: channelID,
		MessageTS: messageTS,
	}
	mock.lockSendProcessingMessage.Lock()
	mock.calls.SendProcessingMessage = append(mock.calls.SendProcessingMessage, callInfo)
	mock.lockSendProcessingMessage.Unlock()
	return mock.SendProcessingMessageFunc(ctx, channelID, messageTS)
}

// SendProcessingMessageCalls gets all the calls that were made to SendProcessingMessage.
// Check the length with:
//
//	len(mockedSlackMessage.SendProcessingMessageCalls())
func (mock *SlackMessageMock) SendProcessingMessageCalls() []struct {
	Ctx       context.Context
	ChannelID string
	MessageTS string
} {
	var calls []struct {
		Ctx       context.Context
		ChannelID string
		MessageTS string
	}
	mock.lockSendProcessingMessage.RLock()
	calls = mock.calls.SendProcessingMessage
	mock.lockSendProcessingMessage.RUnlock()
	return calls
}

// Ensure, that IncidentMock does implement interfaces.Incident.
// If this is not the case, regenerate this file with moq.
var _ interfaces.Incident = &IncidentMock{}

// IncidentMock is a mock implementation of interfaces.Incident.
//
//	func TestSomethingThatUsesIncident(t *testing.T) {
//
//		// make and configure a mocked interfaces.Incident
//		mockedIncident := &IncidentMock{
//			CreateIncidentFunc: func(ctx context.Context, req *model.CreateIncidentRequest) (*model.Incident, error) {
//				panic("mock out the CreateIncident method")
//			},
//			CreateIncidentFromInteractionFunc: func(ctx context.Context, originChannelID string, title string, userID string) (*model.Incident, error) {
//				panic("mock out the CreateIncidentFromInteraction method")
//			},
//			GetIncidentFunc: func(ctx context.Context, id int) (*model.Incident, error) {
//				panic("mock out the GetIncident method")
//			},
//			GetIncidentByChannelIDFunc: func(ctx context.Context, channelID types.ChannelID) (*model.Incident, error) {
//				panic("mock out the GetIncidentByChannelID method")
//			},
//			GetIncidentRequestFunc: func(ctx context.Context, requestID string) (*model.IncidentRequest, error) {
//				panic("mock out the GetIncidentRequest method")
//			},
//			HandleCreateIncidentActionFunc: func(ctx context.Context, requestID string, userID string) (*model.Incident, error) {
//				panic("mock out the HandleCreateIncidentAction method")
//			},
//			HandleCreateIncidentActionAsyncFunc: func(ctx context.Context, requestID string, userID string, channelID string)  {
//				panic("mock out the HandleCreateIncidentActionAsync method")
//			},
//			HandleCreateIncidentWithDetailsFunc: func(ctx context.Context, requestID string, title string, description string, categoryID string, userID string) (*model.Incident, error) {
//				panic("mock out the HandleCreateIncidentWithDetails method")
//			},
//			HandleEditIncidentActionFunc: func(ctx context.Context, requestID string, userID string, triggerID string) error {
//				panic("mock out the HandleEditIncidentAction method")
//			},
//			UpdateIncidentDetailsFunc: func(ctx context.Context, incidentID types.IncidentID, title string, description string, lead types.SlackUserID) (*model.Incident, error) {
//				panic("mock out the UpdateIncidentDetails method")
//			},
//		}
//
//		// use mockedIncident in code that requires interfaces.Incident
//		// and then make assertions.
//
//	}
type IncidentMock struct {
	// CreateIncidentFunc mocks the CreateIncident method.
	CreateIncidentFunc func(ctx context.Context, req *model.CreateIncidentRequest) (*model.Incident, error)

	// CreateIncidentFromInteractionFunc mocks the CreateIncidentFromInteraction method.
	CreateIncidentFromInteractionFunc func(ctx context.Context, originChannelID string, title string, userID string) (*model.Incident, error)

	// GetIncidentFunc mocks the GetIncident method.
	GetIncidentFunc func(ctx context.Context, id int) (*model.Incident, error)

	// GetIncidentByChannelIDFunc mocks the GetIncidentByChannelID method.
	GetIncidentByChannelIDFunc func(ctx context.Context, channelID types.ChannelID) (*model.Incident, error)

	// GetIncidentRequestFunc mocks the GetIncidentRequest method.
	GetIncidentRequestFunc func(ctx context.Context, requestID string) (*model.IncidentRequest, error)

	// HandleCreateIncidentActionFunc mocks the HandleCreateIncidentAction method.
	HandleCreateIncidentActionFunc func(ctx context.Context, requestID string, userID string) (*model.Incident, error)

	// HandleCreateIncidentActionAsyncFunc mocks the HandleCreateIncidentActionAsync method.
	HandleCreateIncidentActionAsyncFunc func(ctx context.Context, requestID string, userID string, channelID string)

	// HandleCreateIncidentWithDetailsFunc mocks the HandleCreateIncidentWithDetails method.
	HandleCreateIncidentWithDetailsFunc func(ctx context.Context, requestID string, title string, description string, categoryID string, userID string) (*model.Incident, error)

	// HandleEditIncidentActionFunc mocks the HandleEditIncidentAction method.
	HandleEditIncidentActionFunc func(ctx context.Context, requestID string, userID string, triggerID string) error

	// UpdateIncidentDetailsFunc mocks the UpdateIncidentDetails method.
	UpdateIncidentDetailsFunc func(ctx context.Context, incidentID types.IncidentID, title string, description string, lead types.SlackUserID) (*model.Incident, error)

	// calls tracks calls to the methods.
	calls struct {
		// CreateIncident holds details about calls to the CreateIncident method.
		CreateIncident []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Req is the req argument value.
			Req *model.CreateIncidentRequest
		}
		// CreateIncidentFromInteraction holds details about calls to the CreateIncidentFromInteraction method.
		CreateIncidentFromInteraction []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// OriginChannelID is the originChannelID argument value.
			OriginChannelID string
			// Title is the title argument value.
			Title string
			// UserID is the userID argument value.
			UserID string
		}
		// GetIncident holds details about calls to the GetIncident method.
		GetIncident []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID int
		}
		// GetIncidentByChannelID holds details about calls to the GetIncidentByChannelID method.
		GetIncidentByChannelID []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ChannelID is the channelID argument value.
			ChannelID types.ChannelID
		}
		// GetIncidentRequest holds details about calls to the GetIncidentRequest method.
		GetIncidentRequest []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// RequestID is the requestID argument value.
			RequestID string
		}
		// HandleCreateIncidentAction holds details about calls to the HandleCreateIncidentAction method.
		HandleCreateIncidentAction []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// RequestID is the requestID argument value.
			RequestID string
			// UserID is the userID argument value.
			UserID string
		}
		// HandleCreateIncidentActionAsync holds details about calls to the HandleCreateIncidentActionAsync method.
		HandleCreateIncidentActionAsync []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// RequestID is the requestID argument value.
			RequestID string
			// UserID is the userID argument value.
			UserID string
			// ChannelID is the channelID argument value.
			ChannelID string
		}
		// HandleCreateIncidentWithDetails holds details about calls to the HandleCreateIncidentWithDetails method.
		HandleCreateIncidentWithDetails []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// RequestID is the requestID argument value.
			RequestID string
			// Title is the title argument value.
			Title string
			// Description is the description argument value.
			Description string
			// CategoryID is the categoryID argument value.
			CategoryID string
			// UserID is the userID argument value.
			UserID string
		}
		// HandleEditIncidentAction holds details about calls to the HandleEditIncidentAction method.
		HandleEditIncidentAction []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// RequestID is the requestID argument value.
			RequestID string
			// UserID is the userID argument value.
			UserID string
			// TriggerID is the triggerID argument value.
			TriggerID string
		}
		// UpdateIncidentDetails holds details about calls to the UpdateIncidentDetails method.
		UpdateIncidentDetails []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// IncidentID is the incidentID argument value.
			IncidentID types.IncidentID
			// Title is the title argument value.
			Title string
			// Description is the description argument value.
			Description string
			// Lead is the lead argument value.
			Lead types.SlackUserID
		}
	}
	lockCreateIncident                  sync.RWMutex
	lockCreateIncidentFromInteraction   sync.RWMutex
	lockGetIncident                     sync.RWMutex
	lockGetIncidentByChannelID          sync.RWMutex
	lockGetIncidentRequest              sync.RWMutex
	lockHandleCreateIncidentAction      sync.RWMutex
	lockHandleCreateIncidentActionAsync sync.RWMutex
	lockHandleCreateIncidentWithDetails sync.RWMutex
	lockHandleEditIncidentAction        sync.RWMutex
	lockUpdateIncidentDetails           sync.RWMutex
}

// CreateIncident calls CreateIncidentFunc.
func (mock *IncidentMock) CreateIncident(ctx context.Context, req *model.CreateIncidentRequest) (*model.Incident, error) {
	if mock.CreateIncidentFunc == nil {
		panic("IncidentMock.CreateIncidentFunc: method is nil but Incident.CreateIncident was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Req *model.CreateIncidentRequest
	}{
		Ctx: ctx,
		Req: req,
	}
	mock.lockCreateIncident.Lock()
	mock.calls.CreateIncident = append(mock.calls.CreateIncident, callInfo)
	mock.lockCreateIncident.Unlock()
	return mock.CreateIncidentFunc(ctx, req)
}

// CreateIncidentCalls gets all the calls that were made to CreateIncident.
// Check the length with:
//
//	len(mockedIncident.CreateIncidentCalls())
func (mock *IncidentMock) CreateIncidentCalls() []struct {
	Ctx context.Context
	Req *model.CreateIncidentRequest
} {
	var calls []struct {
		Ctx context.Context
		Req *model.CreateIncidentRequest
	}
	mock.lockCreateIncident.RLock()
	calls = mock.calls.CreateIncident
	mock.lockCreateIncident.RUnlock()
	return calls
}

// CreateIncidentFromInteraction calls CreateIncidentFromInteractionFunc.
func (mock *IncidentMock) CreateIncidentFromInteraction(ctx context.Context, originChannelID string, title string, userID string) (*model.Incident, error) {
	if mock.CreateIncidentFromInteractionFunc == nil {
		panic("IncidentMock.CreateIncidentFromInteractionFunc: method is nil but Incident.CreateIncidentFromInteraction was just called")
	}
	callInfo := struct {
		Ctx             context.Context
		OriginChannelID string
		Title           string
		UserID          string
	}{
		Ctx:             ctx,
		OriginChannelID: originChannelID,
		Title:           title,
		UserID:          userID,
	}
	mock.lockCreateIncidentFromInteraction.Lock()
	mock.calls.CreateIncidentFromInteraction = append(mock.calls.CreateIncidentFromInteraction, callInfo)
	mock.lockCreateIncidentFromInteraction.Unlock()
	return mock.CreateIncidentFromInteractionFunc(ctx, originChannelID, title, userID)
}

// CreateIncidentFromInteractionCalls gets all the calls that were made to CreateIncidentFromInteraction.
// Check the length with:
//
//	len(mockedIncident.CreateIncidentFromInteractionCalls())
func (mock *IncidentMock) CreateIncidentFromInteractionCalls() []struct {
	Ctx             context.Context
	OriginChannelID string
	Title           string
	UserID          string
} {
	var calls []struct {
		Ctx             context.Context
		OriginChannelID string
		Title           string
		UserID          string
	}
	mock.lockCreateIncidentFromInteraction.RLock()
	calls = mock.calls.CreateIncidentFromInteraction
	mock.lockCreateIncidentFromInteraction.RUnlock()
	return calls
}

// GetIncident calls GetIncidentFunc.
func (mock *IncidentMock) GetIncident(ctx context.Context, id int) (*model.Incident, error) {
	if mock.GetIncidentFunc == nil {
		panic("IncidentMock.GetIncidentFunc: method is nil but Incident.GetIncident was just called")
	}
	callInfo := struct {
		Ctx context.Context
		ID  int
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockGetIncident.Lock()
	mock.calls.GetIncident = append(mock.calls.GetIncident, callInfo)
	mock.lockGetIncident.Unlock()
	return mock.GetIncidentFunc(ctx, id)
}

// GetIncidentCalls gets all the calls that were made to GetIncident.
// Check the length with:
//
//	len(mockedIncident.GetIncidentCalls())
func (mock *IncidentMock) GetIncidentCalls() []struct {
	Ctx context.Context
	ID  int
} {
	var calls []struct {
		Ctx context.Context
		ID  int
	}
	mock.lockGetIncident.RLock()
	calls = mock.calls.GetIncident
	mock.lockGetIncident.RUnlock()
	return calls
}

// GetIncidentByChannelID calls GetIncidentByChannelIDFunc.
func (mock *IncidentMock) GetIncidentByChannelID(ctx context.Context, channelID types.ChannelID) (*model.Incident, error) {
	if mock.GetIncidentByChannelIDFunc == nil {
		panic("IncidentMock.GetIncidentByChannelIDFunc: method is nil but Incident.GetIncidentByChannelID was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		ChannelID types.ChannelID
	}{
		Ctx:       ctx,
		ChannelID: channelID,
	}
	mock.lockGetIncidentByChannelID.Lock()
	mock.calls.GetIncidentByChannelID = append(mock.calls.GetIncidentByChannelID, callInfo)
	mock.lockGetIncidentByChannelID.Unlock()
	return mock.GetIncidentByChannelIDFunc(ctx, channelID)
}

// GetIncidentByChannelIDCalls gets all the calls that were made to GetIncidentByChannelID.
// Check the length with:
//
//	len(mockedIncident.GetIncidentByChannelIDCalls())
func (mock *IncidentMock) GetIncidentByChannelIDCalls() []struct {
	Ctx       context.Context
	ChannelID types.ChannelID
} {
	var calls []struct {
		Ctx       context.Context
		ChannelID types.ChannelID
	}
	mock.lockGetIncidentByChannelID.RLock()
	calls = mock.calls.GetIncidentByChannelID
	mock.lockGetIncidentByChannelID.RUnlock()
	return calls
}

// GetIncidentRequest calls GetIncidentRequestFunc.
func (mock *IncidentMock) GetIncidentRequest(ctx context.Context, requestID string) (*model.IncidentRequest, error) {
	if mock.GetIncidentRequestFunc == nil {
		panic("IncidentMock.GetIncidentRequestFunc: method is nil but Incident.GetIncidentRequest was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		RequestID string
	}{
		Ctx:       ctx,
		RequestID: requestID,
	}
	mock.lockGetIncidentRequest.Lock()
	mock.calls.GetIncidentRequest = append(mock.calls.GetIncidentRequest, callInfo)
	mock.lockGetIncidentRequest.Unlock()
	return mock.GetIncidentRequestFunc(ctx, requestID)
}

// GetIncidentRequestCalls gets all the calls that were made to GetIncidentRequest.
// Check the length with:
//
//	len(mockedIncident.GetIncidentRequestCalls())
func (mock *IncidentMock) GetIncidentRequestCalls() []struct {
	Ctx       context.Context
	RequestID string
} {
	var calls []struct {
		Ctx       context.Context
		RequestID string
	}
	mock.lockGetIncidentRequest.RLock()
	calls = mock.calls.GetIncidentRequest
	mock.lockGetIncidentRequest.RUnlock()
	return calls
}

// HandleCreateIncidentAction calls HandleCreateIncidentActionFunc.
func (mock *IncidentMock) HandleCreateIncidentAction(ctx context.Context, requestID string, userID string) (*model.Incident, error) {
	if mock.HandleCreateIncidentActionFunc == nil {
		panic("IncidentMock.HandleCreateIncidentActionFunc: method is nil but Incident.HandleCreateIncidentAction was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		RequestID string
		UserID    string
	}{
		Ctx:       ctx,
		RequestID: requestID,
		UserID:    userID,
	}
	mock.lockHandleCreateIncidentAction.Lock()
	mock.calls.HandleCreateIncidentAction = append(mock.calls.HandleCreateIncidentAction, callInfo)
	mock.lockHandleCreateIncidentAction.Unlock()
	return mock.HandleCreateIncidentActionFunc(ctx, requestID, userID)
}

// HandleCreateIncidentActionCalls gets all the calls that were made to HandleCreateIncidentAction.
// Check the length with:
//
//	len(mockedIncident.HandleCreateIncidentActionCalls())
func (mock *IncidentMock) HandleCreateIncidentActionCalls() []struct {
	Ctx       context.Context
	RequestID string
	UserID    string
} {
	var calls []struct {
		Ctx       context.Context
		RequestID string
		UserID    string
	}
	mock.lockHandleCreateIncidentAction.RLock()
	calls = mock.calls.HandleCreateIncidentAction
	mock.lockHandleCreateIncidentAction.RUnlock()
	return calls
}

// HandleCreateIncidentActionAsync calls HandleCreateIncidentActionAsyncFunc.
func (mock *IncidentMock) HandleCreateIncidentActionAsync(ctx context.Context, requestID string, userID string, channelID string) {
	if mock.HandleCreateIncidentActionAsyncFunc == nil {
		panic("IncidentMock.HandleCreateIncidentActionAsyncFunc: method is nil but Incident.HandleCreateIncidentActionAsync was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		RequestID string
		UserID    string
		ChannelID string
	}{
		Ctx:       ctx,
		RequestID: requestID,
		UserID:    userID,
		ChannelID: channelID,
	}
	mock.lockHandleCreateIncidentActionAsync.Lock()
	mock.calls.HandleCreateIncidentActionAsync = append(mock.calls.HandleCreateIncidentActionAsync, callInfo)
	mock.lockHandleCreateIncidentActionAsync.Unlock()
	mock.HandleCreateIncidentActionAsyncFunc(ctx, requestID, userID, channelID)
}

// HandleCreateIncidentActionAsyncCalls gets all the calls that were made to HandleCreateIncidentActionAsync.
// Check the length with:
//
//	len(mockedIncident.HandleCreateIncidentActionAsyncCalls())
func (mock *IncidentMock) HandleCreateIncidentActionAsyncCalls() []struct {
	Ctx       context.Context
	RequestID string
	UserID    string
	ChannelID string
} {
	var calls []struct {
		Ctx       context.Context
		RequestID string
		UserID    string
		ChannelID string
	}
	mock.lockHandleCreateIncidentActionAsync.RLock()
	calls = mock.calls.HandleCreateIncidentActionAsync
	mock.lockHandleCreateIncidentActionAsync.RUnlock()
	return calls
}

// HandleCreateIncidentWithDetails calls HandleCreateIncidentWithDetailsFunc.
func (mock *IncidentMock) HandleCreateIncidentWithDetails(ctx context.Context, requestID string, title string, description string, categoryID string, userID string) (*model.Incident, error) {
	if mock.HandleCreateIncidentWithDetailsFunc == nil {
		panic("IncidentMock.HandleCreateIncidentWithDetailsFunc: method is nil but Incident.HandleCreateIncidentWithDetails was just called")
	}
	callInfo := struct {
		Ctx         context.Context
		RequestID   string
		Title       string
		Description string
		CategoryID  string
		UserID      string
	}{
		Ctx:         ctx,
		RequestID:   requestID,
		Title:       title,
		Description: description,
		CategoryID:  categoryID,
		UserID:      userID,
	}
	mock.lockHandleCreateIncidentWithDetails.Lock()
	mock.calls.HandleCreateIncidentWithDetails = append(mock.calls.HandleCreateIncidentWithDetails, callInfo)
	mock.lockHandleCreateIncidentWithDetails.Unlock()
	return mock.HandleCreateIncidentWithDetailsFunc(ctx, requestID, title, description, categoryID, userID)
}

// HandleCreateIncidentWithDetailsCalls gets all the calls that were made to HandleCreateIncidentWithDetails.
// Check the length with:
//
//	len(mockedIncident.HandleCreateIncidentWithDetailsCalls())
func (mock *IncidentMock) HandleCreateIncidentWithDetailsCalls() []struct {
	Ctx         context.Context
	RequestID   string
	Title       string
	Description string
	CategoryID  string
	UserID      string
} {
	var calls []struct {
		Ctx         context.Context
		RequestID   string
		Title       string
		Description string
		CategoryID  string
		UserID      string
	}
	mock.lockHandleCreateIncidentWithDetails.RLock()
	calls = mock.calls.HandleCreateIncidentWithDetails
	mock.lockHandleCreateIncidentWithDetails.RUnlock()
	return calls
}

// HandleEditIncidentAction calls HandleEditIncidentActionFunc.
func (mock *IncidentMock) HandleEditIncidentAction(ctx context.Context, requestID string, userID string, triggerID string) error {
	if mock.HandleEditIncidentActionFunc == nil {
		panic("IncidentMock.HandleEditIncidentActionFunc: method is nil but Incident.HandleEditIncidentAction was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		RequestID string
		UserID    string
		TriggerID string
	}{
		Ctx:       ctx,
		RequestID: requestID,
		UserID:    userID,
		TriggerID: triggerID,
	}
	mock.lockHandleEditIncidentAction.Lock()
	mock.calls.HandleEditIncidentAction = append(mock.calls.HandleEditIncidentAction, callInfo)
	mock.lockHandleEditIncidentAction.Unlock()
	return mock.HandleEditIncidentActionFunc(ctx, requestID, userID, triggerID)
}

// HandleEditIncidentActionCalls gets all the calls that were made to HandleEditIncidentAction.
// Check the length with:
//
//	len(mockedIncident.HandleEditIncidentActionCalls())
func (mock *IncidentMock) HandleEditIncidentActionCalls() []struct {
	Ctx       context.Context
	RequestID string
	UserID    string
	TriggerID string
} {
	var calls []struct {
		Ctx       context.Context
		RequestID string
		UserID    string
		TriggerID string
	}
	mock.lockHandleEditIncidentAction.RLock()
	calls = mock.calls.HandleEditIncidentAction
	mock.lockHandleEditIncidentAction.RUnlock()
	return calls
}

// UpdateIncidentDetails calls UpdateIncidentDetailsFunc.
func (mock *IncidentMock) UpdateIncidentDetails(ctx context.Context, incidentID types.IncidentID, title string, description string, lead types.SlackUserID) (*model.Incident, error) {
	if mock.UpdateIncidentDetailsFunc == nil {
		panic("IncidentMock.UpdateIncidentDetailsFunc: method is nil but Incident.UpdateIncidentDetails was just called")
	}
	callInfo := struct {
		Ctx         context.Context
		IncidentID  types.IncidentID
		Title       string
		Description string
		Lead        types.SlackUserID
	}{
		Ctx:         ctx,
		IncidentID:  incidentID,
		Title:       title,
		Description: description,
		Lead:        lead,
	}
	mock.lockUpdateIncidentDetails.Lock()
	mock.calls.UpdateIncidentDetails = append(mock.calls.UpdateIncidentDetails, callInfo)
	mock.lockUpdateIncidentDetails.Unlock()
	return mock.UpdateIncidentDetailsFunc(ctx, incidentID, title, description, lead)
}

// UpdateIncidentDetailsCalls gets all the calls that were made to UpdateIncidentDetails.
// Check the length with:
//
//	len(mockedIncident.UpdateIncidentDetailsCalls())
func (mock *IncidentMock) UpdateIncidentDetailsCalls() []struct {
	Ctx         context.Context
	IncidentID  types.IncidentID
	Title       string
	Description string
	Lead        types.SlackUserID
} {
	var calls []struct {
		Ctx         context.Context
		IncidentID  types.IncidentID
		Title       string
		Description string
		Lead        types.SlackUserID
	}
	mock.lockUpdateIncidentDetails.RLock()
	calls = mock.calls.UpdateIncidentDetails
	mock.lockUpdateIncidentDetails.RUnlock()
	return calls
}

// Ensure, that TaskMock does implement interfaces.Task.
// If this is not the case, regenerate this file with moq.
var _ interfaces.Task = &TaskMock{}

// TaskMock is a mock implementation of interfaces.Task.
//
//	func TestSomethingThatUsesTask(t *testing.T) {
//
//		// make and configure a mocked interfaces.Task
//		mockedTask := &TaskMock{
//			CompleteTaskFunc: func(ctx context.Context, taskID types.TaskID) (*model.Task, error) {
//				panic("mock out the CompleteTask method")
//			},
//			CompleteTaskByIncidentFunc: func(ctx context.Context, incidentID types.IncidentID, taskID types.TaskID) (*model.Task, error) {
//				panic("mock out the CompleteTaskByIncident method")
//			},
//			CreateTaskFunc: func(ctx context.Context, incidentID types.IncidentID, title string, userID types.SlackUserID, channelID types.ChannelID, messageTS string) (*model.Task, error) {
//				panic("mock out the CreateTask method")
//			},
//			GetTaskFunc: func(ctx context.Context, taskID types.TaskID) (*model.Task, error) {
//				panic("mock out the GetTask method")
//			},
//			GetTaskByIncidentFunc: func(ctx context.Context, incidentID types.IncidentID, taskID types.TaskID) (*model.Task, error) {
//				panic("mock out the GetTaskByIncident method")
//			},
//			ListTasksFunc: func(ctx context.Context, incidentID types.IncidentID) ([]*model.Task, error) {
//				panic("mock out the ListTasks method")
//			},
//			UncompleteTaskFunc: func(ctx context.Context, taskID types.TaskID) (*model.Task, error) {
//				panic("mock out the UncompleteTask method")
//			},
//			UncompleteTaskByIncidentFunc: func(ctx context.Context, incidentID types.IncidentID, taskID types.TaskID) (*model.Task, error) {
//				panic("mock out the UncompleteTaskByIncident method")
//			},
//			UpdateTaskFunc: func(ctx context.Context, taskID types.TaskID, updates interfaces.TaskUpdateRequest) (*model.Task, error) {
//				panic("mock out the UpdateTask method")
//			},
//			UpdateTaskByIncidentFunc: func(ctx context.Context, incidentID types.IncidentID, taskID types.TaskID, updates interfaces.TaskUpdateRequest) (*model.Task, error) {
//				panic("mock out the UpdateTaskByIncident method")
//			},
//		}
//
//		// use mockedTask in code that requires interfaces.Task
//		// and then make assertions.
//
//	}
type TaskMock struct {
	// CompleteTaskFunc mocks the CompleteTask method.
	CompleteTaskFunc func(ctx context.Context, taskID types.TaskID) (*model.Task, error)

	// CompleteTaskByIncidentFunc mocks the CompleteTaskByIncident method.
	CompleteTaskByIncidentFunc func(ctx context.Context, incidentID types.IncidentID, taskID types.TaskID) (*model.Task, error)

	// CreateTaskFunc mocks the CreateTask method.
	CreateTaskFunc func(ctx context.Context, incidentID types.IncidentID, title string, userID types.SlackUserID, channelID types.ChannelID, messageTS string) (*model.Task, error)

	// GetTaskFunc mocks the GetTask method.
	GetTaskFunc func(ctx context.Context, taskID types.TaskID) (*model.Task, error)

	// GetTaskByIncidentFunc mocks the GetTaskByIncident method.
	GetTaskByIncidentFunc func(ctx context.Context, incidentID types.IncidentID, taskID types.TaskID) (*model.Task, error)

	// ListTasksFunc mocks the ListTasks method.
	ListTasksFunc func(ctx context.Context, incidentID types.IncidentID) ([]*model.Task, error)

	// UncompleteTaskFunc mocks the UncompleteTask method.
	UncompleteTaskFunc func(ctx context.Context, taskID types.TaskID) (*model.Task, error)

	// UncompleteTaskByIncidentFunc mocks the UncompleteTaskByIncident method.
	UncompleteTaskByIncidentFunc func(ctx context.Context, incidentID types.IncidentID, taskID types.TaskID) (*model.Task, error)

	// UpdateTaskFunc mocks the UpdateTask method.
	UpdateTaskFunc func(ctx context.Context, taskID types.TaskID, updates interfaces.TaskUpdateRequest) (*model.Task, error)

	// UpdateTaskByIncidentFunc mocks the UpdateTaskByIncident method.
	UpdateTaskByIncidentFunc func(ctx context.Context, incidentID types.IncidentID, taskID types.TaskID, updates interfaces.TaskUpdateRequest) (*model.Task, error)

	// calls tracks calls to the methods.
	calls struct {
		// CompleteTask holds details about calls to the CompleteTask method.
		CompleteTask []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// TaskID is the taskID argument value.
			TaskID types.TaskID
		}
		// CompleteTaskByIncident holds details about calls to the CompleteTaskByIncident method.
		CompleteTaskByIncident []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// IncidentID is the incidentID argument value.
			IncidentID types.IncidentID
			// TaskID is the taskID argument value.
			TaskID types.TaskID
		}
		// CreateTask holds details about calls to the CreateTask method.
		CreateTask []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// IncidentID is the incidentID argument value.
			IncidentID types.IncidentID
			// Title is the title argument value.
			Title string
			// UserID is the userID argument value.
			UserID types.SlackUserID
			// ChannelID is the channelID argument value.
			ChannelID types.ChannelID
			// MessageTS is the messageTS argument value.
			MessageTS string
		}
		// GetTask holds details about calls to the GetTask method.
		GetTask []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// TaskID is the taskID argument value.
			TaskID types.TaskID
		}
		// GetTaskByIncident holds details about calls to the GetTaskByIncident method.
		GetTaskByIncident []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// IncidentID is the incidentID argument value.
			IncidentID types.IncidentID
			// TaskID is the taskID argument value.
			TaskID types.TaskID
		}
		// ListTasks holds details about calls to the ListTasks method.
		ListTasks []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// IncidentID is the incidentID argument value.
			IncidentID types.IncidentID
		}
		// UncompleteTask holds details about calls to the UncompleteTask method.
		UncompleteTask []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// TaskID is the taskID argument value.
			TaskID types.TaskID
		}
		// UncompleteTaskByIncident holds details about calls to the UncompleteTaskByIncident method.
		UncompleteTaskByIncident []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// IncidentID is the incidentID argument value.
			IncidentID types.IncidentID
			// TaskID is the taskID argument value.
			TaskID types.TaskID
		}
		// UpdateTask holds details about calls to the UpdateTask method.
		UpdateTask []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// TaskID is the taskID argument value.
			TaskID types.TaskID
			// Updates is the updates argument value.
			Updates interfaces.TaskUpdateRequest
		}
		// UpdateTaskByIncident holds details about calls to the UpdateTaskByIncident method.
		UpdateTaskByIncident []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// IncidentID is the incidentID argument value.
			IncidentID types.IncidentID
			// TaskID is the taskID argument value.
			TaskID types.TaskID
			// Updates is the updates argument value.
			Updates interfaces.TaskUpdateRequest
		}
	}
	lockCompleteTask             sync.RWMutex
	lockCompleteTaskByIncident   sync.RWMutex
	lockCreateTask               sync.RWMutex
	lockGetTask                  sync.RWMutex
	lockGetTaskByIncident        sync.RWMutex
	lockListTasks                sync.RWMutex
	lockUncompleteTask           sync.RWMutex
	lockUncompleteTaskByIncident sync.RWMutex
	lockUpdateTask               sync.RWMutex
	lockUpdateTaskByIncident     sync.RWMutex
}

// CompleteTask calls CompleteTaskFunc.
func (mock *TaskMock) CompleteTask(ctx context.Context, taskID types.TaskID) (*model.Task, error) {
	if mock.CompleteTaskFunc == nil {
		panic("TaskMock.CompleteTaskFunc: method is nil but Task.CompleteTask was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		TaskID types.TaskID
	}{
		Ctx:    ctx,
		TaskID: taskID,
	}
	mock.lockCompleteTask.Lock()
	mock.calls.CompleteTask = append(mock.calls.CompleteTask, callInfo)
	mock.lockCompleteTask.Unlock()
	return mock.CompleteTaskFunc(ctx, taskID)
}

// CompleteTaskCalls gets all the calls that were made to CompleteTask.
// Check the length with:
//
//	len(mockedTask.CompleteTaskCalls())
func (mock *TaskMock) CompleteTaskCalls() []struct {
	Ctx    context.Context
	TaskID types.TaskID
} {
	var calls []struct {
		Ctx    context.Context
		TaskID types.TaskID
	}
	mock.lockCompleteTask.RLock()
	calls = mock.calls.CompleteTask
	mock.lockCompleteTask.RUnlock()
	return calls
}

// CompleteTaskByIncident calls CompleteTaskByIncidentFunc.
func (mock *TaskMock) CompleteTaskByIncident(ctx context.Context, incidentID types.IncidentID, taskID types.TaskID) (*model.Task, error) {
	if mock.CompleteTaskByIncidentFunc == nil {
		panic("TaskMock.CompleteTaskByIncidentFunc: method is nil but Task.CompleteTaskByIncident was just called")
	}
	callInfo := struct {
		Ctx        context.Context
		IncidentID types.IncidentID
		TaskID     types.TaskID
	}{
		Ctx:        ctx,
		IncidentID: incidentID,
		TaskID:     taskID,
	}
	mock.lockCompleteTaskByIncident.Lock()
	mock.calls.CompleteTaskByIncident = append(mock.calls.CompleteTaskByIncident, callInfo)
	mock.lockCompleteTaskByIncident.Unlock()
	return mock.CompleteTaskByIncidentFunc(ctx, incidentID, taskID)
}

// CompleteTaskByIncidentCalls gets all the calls that were made to CompleteTaskByIncident.
// Check the length with:
//
//	len(mockedTask.CompleteTaskByIncidentCalls())
func (mock *TaskMock) CompleteTaskByIncidentCalls() []struct {
	Ctx        context.Context
	IncidentID types.IncidentID
	TaskID     types.TaskID
} {
	var calls []struct {
		Ctx        context.Context
		IncidentID types.IncidentID
		TaskID     types.TaskID
	}
	mock.lockCompleteTaskByIncident.RLock()
	calls = mock.calls.CompleteTaskByIncident
	mock.lockCompleteTaskByIncident.RUnlock()
	return calls
}

// CreateTask calls CreateTaskFunc.
func (mock *TaskMock) CreateTask(ctx context.Context, incidentID types.IncidentID, title string, userID types.SlackUserID, channelID types.ChannelID, messageTS string) (*model.Task, error) {
	if mock.CreateTaskFunc == nil {
		panic("TaskMock.CreateTaskFunc: method is nil but Task.CreateTask was just called")
	}
	callInfo := struct {
		Ctx        context.Context
		IncidentID types.IncidentID
		Title      string
		UserID     types.SlackUserID
		ChannelID  types.ChannelID
		MessageTS  string
	}{
		Ctx:        ctx,
		IncidentID: incidentID,
		Title:      title,
		UserID:     userID,
		ChannelID:  channelID,
		MessageTS:  messageTS,
	}
	mock.lockCreateTask.Lock()
	mock.calls.CreateTask = append(mock.calls.CreateTask, callInfo)
	mock.lockCreateTask.Unlock()
	return mock.CreateTaskFunc(ctx, incidentID, title, userID, channelID, messageTS)
}

// CreateTaskCalls gets all the calls that were made to CreateTask.
// Check the length with:
//
//	len(mockedTask.CreateTaskCalls())
func (mock *TaskMock) CreateTaskCalls() []struct {
	Ctx        context.Context
	IncidentID types.IncidentID
	Title      string
	UserID     types.SlackUserID
	ChannelID  types.ChannelID
	MessageTS  string
} {
	var calls []struct {
		Ctx        context.Context
		IncidentID types.IncidentID
		Title      string
		UserID     types.SlackUserID
		ChannelID  types.ChannelID
		MessageTS  string
	}
	mock.lockCreateTask.RLock()
	calls = mock.calls.CreateTask
	mock.lockCreateTask.RUnlock()
	return calls
}

// GetTask calls GetTaskFunc.
func (mock *TaskMock) GetTask(ctx context.Context, taskID types.TaskID) (*model.Task, error) {
	if mock.GetTaskFunc == nil {
		panic("TaskMock.GetTaskFunc: method is nil but Task.GetTask was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		TaskID types.TaskID
	}{
		Ctx:    ctx,
		TaskID: taskID,
	}
	mock.lockGetTask.Lock()
	mock.calls.GetTask = append(mock.calls.GetTask, callInfo)
	mock.lockGetTask.Unlock()
	return mock.GetTaskFunc(ctx, taskID)
}

// GetTaskCalls gets all the calls that were made to GetTask.
// Check the length with:
//
//	len(mockedTask.GetTaskCalls())
func (mock *TaskMock) GetTaskCalls() []struct {
	Ctx    context.Context
	TaskID types.TaskID
} {
	var calls []struct {
		Ctx    context.Context
		TaskID types.TaskID
	}
	mock.lockGetTask.RLock()
	calls = mock.calls.GetTask
	mock.lockGetTask.RUnlock()
	return calls
}

// GetTaskByIncident calls GetTaskByIncidentFunc.
func (mock *TaskMock) GetTaskByIncident(ctx context.Context, incidentID types.IncidentID, taskID types.TaskID) (*model.Task, error) {
	if mock.GetTaskByIncidentFunc == nil {
		panic("TaskMock.GetTaskByIncidentFunc: method is nil but Task.GetTaskByIncident was just called")
	}
	callInfo := struct {
		Ctx        context.Context
		IncidentID types.IncidentID
		TaskID     types.TaskID
	}{
		Ctx:        ctx,
		IncidentID: incidentID,
		TaskID:     taskID,
	}
	mock.lockGetTaskByIncident.Lock()
	mock.calls.GetTaskByIncident = append(mock.calls.GetTaskByIncident, callInfo)
	mock.lockGetTaskByIncident.Unlock()
	return mock.GetTaskByIncidentFunc(ctx, incidentID, taskID)
}

// GetTaskByIncidentCalls gets all the calls that were made to GetTaskByIncident.
// Check the length with:
//
//	len(mockedTask.GetTaskByIncidentCalls())
func (mock *TaskMock) GetTaskByIncidentCalls() []struct {
	Ctx        context.Context
	IncidentID types.IncidentID
	TaskID     types.TaskID
} {
	var calls []struct {
		Ctx        context.Context
		IncidentID types.IncidentID
		TaskID     types.TaskID
	}
	mock.lockGetTaskByIncident.RLock()
	calls = mock.calls.GetTaskByIncident
	mock.lockGetTaskByIncident.RUnlock()
	return calls
}

// ListTasks calls ListTasksFunc.
func (mock *TaskMock) ListTasks(ctx context.Context, incidentID types.IncidentID) ([]*model.Task, error) {
	if mock.ListTasksFunc == nil {
		panic("TaskMock.ListTasksFunc: method is nil but Task.ListTasks was just called")
	}
	callInfo := struct {
		Ctx        context.Context
		IncidentID types.IncidentID
	}{
		Ctx:        ctx,
		IncidentID: incidentID,
	}
	mock.lockListTasks.Lock()
	mock.calls.ListTasks = append(mock.calls.ListTasks, callInfo)
	mock.lockListTasks.Unlock()
	return mock.ListTasksFunc(ctx, incidentID)
}

// ListTasksCalls gets all the calls that were made to ListTasks.
// Check the length with:
//
//	len(mockedTask.ListTasksCalls())
func (mock *TaskMock) ListTasksCalls() []struct {
	Ctx        context.Context
	IncidentID types.IncidentID
} {
	var calls []struct {
		Ctx        context.Context
		IncidentID types.IncidentID
	}
	mock.lockListTasks.RLock()
	calls = mock.calls.ListTasks
	mock.lockListTasks.RUnlock()
	return calls
}

// UncompleteTask calls UncompleteTaskFunc.
func (mock *TaskMock) UncompleteTask(ctx context.Context, taskID types.TaskID) (*model.Task, error) {
	if mock.UncompleteTaskFunc == nil {
		panic("TaskMock.UncompleteTaskFunc: method is nil but Task.UncompleteTask was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		TaskID types.TaskID
	}{
		Ctx:    ctx,
		TaskID: taskID,
	}
	mock.lockUncompleteTask.Lock()
	mock.calls.UncompleteTask = append(mock.calls.UncompleteTask, callInfo)
	mock.lockUncompleteTask.Unlock()
	return mock.UncompleteTaskFunc(ctx, taskID)
}

// UncompleteTaskCalls gets all the calls that were made to UncompleteTask.
// Check the length with:
//
//	len(mockedTask.UncompleteTaskCalls())
func (mock *TaskMock) UncompleteTaskCalls() []struct {
	Ctx    context.Context
	TaskID types.TaskID
} {
	var calls []struct {
		Ctx    context.Context
		TaskID types.TaskID
	}
	mock.lockUncompleteTask.RLock()
	calls = mock.calls.UncompleteTask
	mock.lockUncompleteTask.RUnlock()
	return calls
}

// UncompleteTaskByIncident calls UncompleteTaskByIncidentFunc.
func (mock *TaskMock) UncompleteTaskByIncident(ctx context.Context, incidentID types.IncidentID, taskID types.TaskID) (*model.Task, error) {
	if mock.UncompleteTaskByIncidentFunc == nil {
		panic("TaskMock.UncompleteTaskByIncidentFunc: method is nil but Task.UncompleteTaskByIncident was just called")
	}
	callInfo := struct {
		Ctx        context.Context
		IncidentID types.IncidentID
		TaskID     types.TaskID
	}{
		Ctx:        ctx,
		IncidentID: incidentID,
		TaskID:     taskID,
	}
	mock.lockUncompleteTaskByIncident.Lock()
	mock.calls.UncompleteTaskByIncident = append(mock.calls.UncompleteTaskByIncident, callInfo)
	mock.lockUncompleteTaskByIncident.Unlock()
	return mock.UncompleteTaskByIncidentFunc(ctx, incidentID, taskID)
}

// UncompleteTaskByIncidentCalls gets all the calls that were made to UncompleteTaskByIncident.
// Check the length with:
//
//	len(mockedTask.UncompleteTaskByIncidentCalls())
func (mock *TaskMock) UncompleteTaskByIncidentCalls() []struct {
	Ctx        context.Context
	IncidentID types.IncidentID
	TaskID     types.TaskID
} {
	var calls []struct {
		Ctx        context.Context
		IncidentID types.IncidentID
		TaskID     types.TaskID
	}
	mock.lockUncompleteTaskByIncident.RLock()
	calls = mock.calls.UncompleteTaskByIncident
	mock.lockUncompleteTaskByIncident.RUnlock()
	return calls
}

// UpdateTask calls UpdateTaskFunc.
func (mock *TaskMock) UpdateTask(ctx context.Context, taskID types.TaskID, updates interfaces.TaskUpdateRequest) (*model.Task, error) {
	if mock.UpdateTaskFunc == nil {
		panic("TaskMock.UpdateTaskFunc: method is nil but Task.UpdateTask was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		TaskID  types.TaskID
		Updates interfaces.TaskUpdateRequest
	}{
		Ctx:     ctx,
		TaskID:  taskID,
		Updates: updates,
	}
	mock.lockUpdateTask.Lock()
	mock.calls.UpdateTask = append(mock.calls.UpdateTask, callInfo)
	mock.lockUpdateTask.Unlock()
	return mock.UpdateTaskFunc(ctx, taskID, updates)
}

// UpdateTaskCalls gets all the calls that were made to UpdateTask.
// Check the length with:
//
//	len(mockedTask.UpdateTaskCalls())
func (mock *TaskMock) UpdateTaskCalls() []struct {
	Ctx     context.Context
	TaskID  types.TaskID
	Updates interfaces.TaskUpdateRequest
} {
	var calls []struct {
		Ctx     context.Context
		TaskID  types.TaskID
		Updates interfaces.TaskUpdateRequest
	}
	mock.lockUpdateTask.RLock()
	calls = mock.calls.UpdateTask
	mock.lockUpdateTask.RUnlock()
	return calls
}

// UpdateTaskByIncident calls UpdateTaskByIncidentFunc.
func (mock *TaskMock) UpdateTaskByIncident(ctx context.Context, incidentID types.IncidentID, taskID types.TaskID, updates interfaces.TaskUpdateRequest) (*model.Task, error) {
	if mock.UpdateTaskByIncidentFunc == nil {
		panic("TaskMock.UpdateTaskByIncidentFunc: method is nil but Task.UpdateTaskByIncident was just called")
	}
	callInfo := struct {
		Ctx        context.Context
		IncidentID types.IncidentID
		TaskID     types.TaskID
		Updates    interfaces.TaskUpdateRequest
	}{
		Ctx:        ctx,
		IncidentID: incidentID,
		TaskID:     taskID,
		Updates:    updates,
	}
	mock.lockUpdateTaskByIncident.Lock()
	mock.calls.UpdateTaskByIncident = append(mock.calls.UpdateTaskByIncident, callInfo)
	mock.lockUpdateTaskByIncident.Unlock()
	return mock.UpdateTaskByIncidentFunc(ctx, incidentID, taskID, updates)
}

// UpdateTaskByIncidentCalls gets all the calls that were made to UpdateTaskByIncident.
// Check the length with:
//
//	len(mockedTask.UpdateTaskByIncidentCalls())
func (mock *TaskMock) UpdateTaskByIncidentCalls() []struct {
	Ctx        context.Context
	IncidentID types.IncidentID
	TaskID     types.TaskID
	Updates    interfaces.TaskUpdateRequest
} {
	var calls []struct {
		Ctx        context.Context
		IncidentID types.IncidentID
		TaskID     types.TaskID
		Updates    interfaces.TaskUpdateRequest
	}
	mock.lockUpdateTaskByIncident.RLock()
	calls = mock.calls.UpdateTaskByIncident
	mock.lockUpdateTaskByIncident.RUnlock()
	return calls
}

// Ensure, that InviteMock does implement interfaces.Invite.
// If this is not the case, regenerate this file with moq.
var _ interfaces.Invite = &InviteMock{}

// InviteMock is a mock implementation of interfaces.Invite.
//
//	func TestSomethingThatUsesInvite(t *testing.T) {
//
//		// make and configure a mocked interfaces.Invite
//		mockedInvite := &InviteMock{
//			InviteUsersByListFunc: func(ctx context.Context, users []string, groups []string, channelID types.ChannelID) (*model.InvitationResult, error) {
//				panic("mock out the InviteUsersByList method")
//			},
//		}
//
//		// use mockedInvite in code that requires interfaces.Invite
//		// and then make assertions.
//
//	}
type InviteMock struct {
	// InviteUsersByListFunc mocks the InviteUsersByList method.
	InviteUsersByListFunc func(ctx context.Context, users []string, groups []string, channelID types.ChannelID) (*model.InvitationResult, error)

	// calls tracks calls to the methods.
	calls struct {
		// InviteUsersByList holds details about calls to the InviteUsersByList method.
		InviteUsersByList []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Users is the users argument value.
			Users []string
			// Groups is the groups argument value.
			Groups []string
			// ChannelID is the channelID argument value.
			ChannelID types.ChannelID
		}
	}
	lockInviteUsersByList sync.RWMutex
}

// InviteUsersByList calls InviteUsersByListFunc.
func (mock *InviteMock) InviteUsersByList(ctx context.Context, users []string, groups []string, channelID types.ChannelID) (*model.InvitationResult, error) {
	if mock.InviteUsersByListFunc == nil {
		panic("InviteMock.InviteUsersByListFunc: method is nil but Invite.InviteUsersByList was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		Users     []string
		Groups    []string
		ChannelID types.ChannelID
	}{
		Ctx:       ctx,
		Users:     users,
		Groups:    groups,
		ChannelID: channelID,
	}
	mock.lockInviteUsersByList.Lock()
	mock.calls.InviteUsersByList = append(mock.calls.InviteUsersByList, callInfo)
	mock.lockInviteUsersByList.Unlock()
	return mock.InviteUsersByListFunc(ctx, users, groups, channelID)
}

// InviteUsersByListCalls gets all the calls that were made to InviteUsersByList.
// Check the length with:
//
//	len(mockedInvite.InviteUsersByListCalls())
func (mock *InviteMock) InviteUsersByListCalls() []struct {
	Ctx       context.Context
	Users     []string
	Groups    []string
	ChannelID types.ChannelID
} {
	var calls []struct {
		Ctx       context.Context
		Users     []string
		Groups    []string
		ChannelID types.ChannelID
	}
	mock.lockInviteUsersByList.RLock()
	calls = mock.calls.InviteUsersByList
	mock.lockInviteUsersByList.RUnlock()
	return calls
}

// Ensure, that StatusUseCaseMock does implement interfaces.StatusUseCase.
// If this is not the case, regenerate this file with moq.
var _ interfaces.StatusUseCase = &StatusUseCaseMock{}

// StatusUseCaseMock is a mock implementation of interfaces.StatusUseCase.
//
//	func TestSomethingThatUsesStatusUseCase(t *testing.T) {
//
//		// make and configure a mocked interfaces.StatusUseCase
//		mockedStatusUseCase := &StatusUseCaseMock{
//			GetStatusHistoryFunc: func(ctx context.Context, incidentID types.IncidentID) ([]*model.StatusHistoryWithUser, error) {
//				panic("mock out the GetStatusHistory method")
//			},
//			HandleEditStatusActionFunc: func(ctx context.Context, incidentIDStr string, userID types.SlackUserID, triggerID string, channelID string, messageTS string) error {
//				panic("mock out the HandleEditStatusAction method")
//			},
//			PostStatusMessageFunc: func(ctx context.Context, channelID types.ChannelID, incidentID types.IncidentID) error {
//				panic("mock out the PostStatusMessage method")
//			},
//			UpdateOriginalStatusMessageFunc: func(ctx context.Context, channelID types.ChannelID, messageTS string, incident *model.Incident) error {
//				panic("mock out the UpdateOriginalStatusMessage method")
//			},
//			UpdateStatusFunc: func(ctx context.Context, incidentID types.IncidentID, status types.IncidentStatus, userID types.SlackUserID, note string) error {
//				panic("mock out the UpdateStatus method")
//			},
//		}
//
//		// use mockedStatusUseCase in code that requires interfaces.StatusUseCase
//		// and then make assertions.
//
//	}
type StatusUseCaseMock struct {
	// GetStatusHistoryFunc mocks the GetStatusHistory method.
	GetStatusHistoryFunc func(ctx context.Context, incidentID types.IncidentID) ([]*model.StatusHistoryWithUser, error)

	// HandleEditStatusActionFunc mocks the HandleEditStatusAction method.
	HandleEditStatusActionFunc func(ctx context.Context, incidentIDStr string, userID types.SlackUserID, triggerID string, channelID string, messageTS string) error

	// PostStatusMessageFunc mocks the PostStatusMessage method.
	PostStatusMessageFunc func(ctx context.Context, channelID types.ChannelID, incidentID types.IncidentID) error

	// UpdateOriginalStatusMessageFunc mocks the UpdateOriginalStatusMessage method.
	UpdateOriginalStatusMessageFunc func(ctx context.Context, channelID types.ChannelID, messageTS string, incident *model.Incident) error

	// UpdateStatusFunc mocks the UpdateStatus method.
	UpdateStatusFunc func(ctx context.Context, incidentID types.IncidentID, status types.IncidentStatus, userID types.SlackUserID, note string) error

	// calls tracks calls to the methods.
	calls struct {
		// GetStatusHistory holds details about calls to the GetStatusHistory method.
		GetStatusHistory []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// IncidentID is the incidentID argument value.
			IncidentID types.IncidentID
		}
		// HandleEditStatusAction holds details about calls to the HandleEditStatusAction method.
		HandleEditStatusAction []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// IncidentIDStr is the incidentIDStr argument value.
			IncidentIDStr string
			// UserID is the userID argument value.
			UserID types.SlackUserID
			// TriggerID is the triggerID argument value.
			TriggerID string
			// ChannelID is the channelID argument value.
			ChannelID string
			// MessageTS is the messageTS argument value.
			MessageTS string
		}
		// PostStatusMessage holds details about calls to the PostStatusMessage method.
		PostStatusMessage []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ChannelID is the channelID argument value.
			ChannelID types.ChannelID
			// IncidentID is the incidentID argument value.
			IncidentID types.IncidentID
		}
		// UpdateOriginalStatusMessage holds details about calls to the UpdateOriginalStatusMessage method.
		UpdateOriginalStatusMessage []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ChannelID is the channelID argument value.
			ChannelID types.ChannelID
			// MessageTS is the messageTS argument value.
			MessageTS string
			// Incident is the incident argument value.
			Incident *model.Incident
		}
		// UpdateStatus holds details about calls to the UpdateStatus method.
		UpdateStatus []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// IncidentID is the incidentID argument value.
			IncidentID types.IncidentID
			// Status is the status argument value.
			Status types.IncidentStatus
			// UserID is the userID argument value.
			UserID types.SlackUserID
			// Note is the note argument value.
			Note string
		}
	}
	lockGetStatusHistory            sync.RWMutex
	lockHandleEditStatusAction      sync.RWMutex
	lockPostStatusMessage           sync.RWMutex
	lockUpdateOriginalStatusMessage sync.RWMutex
	lockUpdateStatus                sync.RWMutex
}

// GetStatusHistory calls GetStatusHistoryFunc.
func (mock *StatusUseCaseMock) GetStatusHistory(ctx context.Context, incidentID types.IncidentID) ([]*model.StatusHistoryWithUser, error) {
	if mock.GetStatusHistoryFunc == nil {
		panic("StatusUseCaseMock.GetStatusHistoryFunc: method is nil but StatusUseCase.GetStatusHistory was just called")
	}
	callInfo := struct {
		Ctx        context.Context
		IncidentID types.IncidentID
	}{
		Ctx:        ctx,
		IncidentID: incidentID,
	}
	mock.lockGetStatusHistory.Lock()
	mock.calls.GetStatusHistory = append(mock.calls.GetStatusHistory, callInfo)
	mock.lockGetStatusHistory.Unlock()
	return mock.GetStatusHistoryFunc(ctx, incidentID)
}

// GetStatusHistoryCalls gets all the calls that were made to GetStatusHistory.
// Check the length with:
//
//	len(mockedStatusUseCase.GetStatusHistoryCalls())
func (mock *StatusUseCaseMock) GetStatusHistoryCalls() []struct {
	Ctx        context.Context
	IncidentID types.IncidentID
} {
	var calls []struct {
		Ctx        context.Context
		IncidentID types.IncidentID
	}
	mock.lockGetStatusHistory.RLock()
	calls = mock.calls.GetStatusHistory
	mock.lockGetStatusHistory.RUnlock()
	return calls
}

// HandleEditStatusAction calls HandleEditStatusActionFunc.
func (mock *StatusUseCaseMock) HandleEditStatusAction(ctx context.Context, incidentIDStr string, userID types.SlackUserID, triggerID string, channelID string, messageTS string) error {
	if mock.HandleEditStatusActionFunc == nil {
		panic("StatusUseCaseMock.HandleEditStatusActionFunc: method is nil but StatusUseCase.HandleEditStatusAction was just called")
	}
	callInfo := struct {
		Ctx           context.Context
		IncidentIDStr string
		UserID        types.SlackUserID
		TriggerID     string
		ChannelID     string
		MessageTS     string
	}{
		Ctx:           ctx,
		IncidentIDStr: incidentIDStr,
		UserID:        userID,
		TriggerID:     triggerID,
		ChannelID:     channelID,
		MessageTS:     messageTS,
	}
	mock.lockHandleEditStatusAction.Lock()
	mock.calls.HandleEditStatusAction = append(mock.calls.HandleEditStatusAction, callInfo)
	mock.lockHandleEditStatusAction.Unlock()
	return mock.HandleEditStatusActionFunc(ctx, incidentIDStr, userID, triggerID, channelID, messageTS)
}

// HandleEditStatusActionCalls gets all the calls that were made to HandleEditStatusAction.
// Check the length with:
//
//	len(mockedStatusUseCase.HandleEditStatusActionCalls())
func (mock *StatusUseCaseMock) HandleEditStatusActionCalls() []struct {
	Ctx           context.Context
	IncidentIDStr string
	UserID        types.SlackUserID
	TriggerID     string
	ChannelID     string
	MessageTS     string
} {
	var calls []struct {
		Ctx           context.Context
		IncidentIDStr string
		UserID        types.SlackUserID
		TriggerID     string
		ChannelID     string
		MessageTS     string
	}
	mock.lockHandleEditStatusAction.RLock()
	calls = mock.calls.HandleEditStatusAction
	mock.lockHandleEditStatusAction.RUnlock()
	return calls
}

// PostStatusMessage calls PostStatusMessageFunc.
func (mock *StatusUseCaseMock) PostStatusMessage(ctx context.Context, channelID types.ChannelID, incidentID types.IncidentID) error {
	if mock.PostStatusMessageFunc == nil {
		panic("StatusUseCaseMock.PostStatusMessageFunc: method is nil but StatusUseCase.PostStatusMessage was just called")
	}
	callInfo := struct {
		Ctx        context.Context
		ChannelID  types.ChannelID
		IncidentID types.IncidentID
	}{
		Ctx:        ctx,
		ChannelID:  channelID,
		IncidentID: incidentID,
	}
	mock.lockPostStatusMessage.Lock()
	mock.calls.PostStatusMessage = append(mock.calls.PostStatusMessage, callInfo)
	mock.lockPostStatusMessage.Unlock()
	return mock.PostStatusMessageFunc(ctx, channelID, incidentID)
}

// PostStatusMessageCalls gets all the calls that were made to PostStatusMessage.
// Check the length with:
//
//	len(mockedStatusUseCase.PostStatusMessageCalls())
func (mock *StatusUseCaseMock) PostStatusMessageCalls() []struct {
	Ctx        context.Context
	ChannelID  types.ChannelID
	IncidentID types.IncidentID
} {
	var calls []struct {
		Ctx        context.Context
		ChannelID  types.ChannelID
		IncidentID types.IncidentID
	}
	mock.lockPostStatusMessage.RLock()
	calls = mock.calls.PostStatusMessage
	mock.lockPostStatusMessage.RUnlock()
	return calls
}

// UpdateOriginalStatusMessage calls UpdateOriginalStatusMessageFunc.
func (mock *StatusUseCaseMock) UpdateOriginalStatusMessage(ctx context.Context, channelID types.ChannelID, messageTS string, incident *model.Incident) error {
	if mock.UpdateOriginalStatusMessageFunc == nil {
		panic("StatusUseCaseMock.UpdateOriginalStatusMessageFunc: method is nil but StatusUseCase.UpdateOriginalStatusMessage was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		ChannelID types.ChannelID
		MessageTS string
		Incident  *model.Incident
	}{
		Ctx:       ctx,
		ChannelID: channelID,
		MessageTS: messageTS,
		Incident:  incident,
	}
	mock.lockUpdateOriginalStatusMessage.Lock()
	mock.calls.UpdateOriginalStatusMessage = append(mock.calls.UpdateOriginalStatusMessage, callInfo)
	mock.lockUpdateOriginalStatusMessage.Unlock()
	return mock.UpdateOriginalStatusMessageFunc(ctx, channelID, messageTS, incident)
}

// UpdateOriginalStatusMessageCalls gets all the calls that were made to UpdateOriginalStatusMessage.
// Check the length with:
//
//	len(mockedStatusUseCase.UpdateOriginalStatusMessageCalls())
func (mock *StatusUseCaseMock) UpdateOriginalStatusMessageCalls() []struct {
	Ctx       context.Context
	ChannelID types.ChannelID
	MessageTS string
	Incident  *model.Incident
} {
	var calls []struct {
		Ctx       context.Context
		ChannelID types.ChannelID
		MessageTS string
		Incident  *model.Incident
	}
	mock.lockUpdateOriginalStatusMessage.RLock()
	calls = mock.calls.UpdateOriginalStatusMessage
	mock.lockUpdateOriginalStatusMessage.RUnlock()
	return calls
}

// UpdateStatus calls UpdateStatusFunc.
func (mock *StatusUseCaseMock) UpdateStatus(ctx context.Context, incidentID types.IncidentID, status types.IncidentStatus, userID types.SlackUserID, note string) error {
	if mock.UpdateStatusFunc == nil {
		panic("StatusUseCaseMock.UpdateStatusFunc: method is nil but StatusUseCase.UpdateStatus was just called")
	}
	callInfo := struct {
		Ctx        context.Context
		IncidentID types.IncidentID
		Status     types.IncidentStatus
		UserID     types.SlackUserID
		Note       string
	}{
		Ctx:        ctx,
		IncidentID: incidentID,
		Status:     status,
		UserID:     userID,
		Note:       note,
	}
	mock.lockUpdateStatus.Lock()
	mock.calls.UpdateStatus = append(mock.calls.UpdateStatus, callInfo)
	mock.lockUpdateStatus.Unlock()
	return mock.UpdateStatusFunc(ctx, incidentID, status, userID, note)
}

// UpdateStatusCalls gets all the calls that were made to UpdateStatus.
// Check the length with:
//
//	len(mockedStatusUseCase.UpdateStatusCalls())
func (mock *StatusUseCaseMock) UpdateStatusCalls() []struct {
	Ctx        context.Context
	IncidentID types.IncidentID
	Status     types.IncidentStatus
	UserID     types.SlackUserID
	Note       string
} {
	var calls []struct {
		Ctx        context.Context
		IncidentID types.IncidentID
		Status     types.IncidentStatus
		UserID     types.SlackUserID
		Note       string
	}
	mock.lockUpdateStatus.RLock()
	calls = mock.calls.UpdateStatus
	mock.lockUpdateStatus.RUnlock()
	return calls
}

// Ensure, that AuthMock does implement interfaces.Auth.
// If this is not the case, regenerate this file with moq.
var _ interfaces.Auth = &AuthMock{}

// AuthMock is a mock implementation of interfaces.Auth.
//
//	func TestSomethingThatUsesAuth(t *testing.T) {
//
//		// make and configure a mocked interfaces.Auth
//		mockedAuth := &AuthMock{
//			CreateSessionFunc: func(ctx context.Context, slackUserID string, userName string, userEmail string) (*model.Session, error) {
//				panic("mock out the CreateSession method")
//			},
//			DeleteSessionFunc: func(ctx context.Context, sessionID string) error {
//				panic("mock out the DeleteSession method")
//			},
//			GenerateOAuthURLFunc: func(ctx context.Context, config interfaces.OAuthConfig) (*interfaces.OAuthURL, error) {
//				panic("mock out the GenerateOAuthURL method")
//			},
//			GetChannelMembersFunc: func(ctx context.Context, channelID string) ([]*model.User, error) {
//				panic("mock out the GetChannelMembers method")
//			},
//			GetUserFromSessionFunc: func(ctx context.Context, sessionID string) (*model.User, error) {
//				panic("mock out the GetUserFromSession method")
//			},
//			HandleCallbackFunc: func(ctx context.Context, code string, redirectURI string) (*model.User, error) {
//				panic("mock out the HandleCallback method")
//			},
//			ValidateSessionFunc: func(ctx context.Context, sessionID string, sessionSecret string) (*model.Session, error) {
//				panic("mock out the ValidateSession method")
//			},
//		}
//
//		// use mockedAuth in code that requires interfaces.Auth
//		// and then make assertions.
//
//	}
type AuthMock struct {
	// CreateSessionFunc mocks the CreateSession method.
	CreateSessionFunc func(ctx context.Context, slackUserID string, userName string, userEmail string) (*model.Session, error)

	// DeleteSessionFunc mocks the DeleteSession method.
	DeleteSessionFunc func(ctx context.Context, sessionID string) error

	// GenerateOAuthURLFunc mocks the GenerateOAuthURL method.
	GenerateOAuthURLFunc func(ctx context.Context, config interfaces.OAuthConfig) (*interfaces.OAuthURL, error)

	// GetChannelMembersFunc mocks the GetChannelMembers method.
	GetChannelMembersFunc func(ctx context.Context, channelID string) ([]*model.User, error)

	// GetUserFromSessionFunc mocks the GetUserFromSession method.
	GetUserFromSessionFunc func(ctx context.Context, sessionID string) (*model.User, error)

	// HandleCallbackFunc mocks the HandleCallback method.
	HandleCallbackFunc func(ctx context.Context, code string, redirectURI string) (*model.User, error)

	// ValidateSessionFunc mocks the ValidateSession method.
	ValidateSessionFunc func(ctx context.Context, sessionID string, sessionSecret string) (*model.Session, error)

	// calls tracks calls to the methods.
	calls struct {
		// CreateSession holds details about calls to the CreateSession method.
		CreateSession []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// SlackUserID is the slackUserID argument value.
			SlackUserID string
			// UserName is the userName argument value.
			UserName string
			// UserEmail is the userEmail argument value.
			UserEmail string
		}
		// DeleteSession holds details about calls to the DeleteSession method.
		DeleteSession []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// SessionID is the sessionID argument value.
			SessionID string
		}
		// GenerateOAuthURL holds details about calls to the GenerateOAuthURL method.
		GenerateOAuthURL []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Config is the config argument value.
			Config interfaces.OAuthConfig
		}
		// GetChannelMembers holds details about calls to the GetChannelMembers method.
		GetChannelMembers []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ChannelID is the channelID argument value.
			ChannelID string
		}
		// GetUserFromSession holds details about calls to the GetUserFromSession method.
		GetUserFromSession []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// SessionID is the sessionID argument value.
			SessionID string
		}
		// HandleCallback holds details about calls to the HandleCallback method.
		HandleCallback []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Code is the code argument value.
			Code string
			// RedirectURI is the redirectURI argument value.
			RedirectURI string
		}
		// ValidateSession holds details about calls to the ValidateSession method.
		ValidateSession []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// SessionID is the sessionID argument value.
			SessionID string
			// SessionSecret is the sessionSecret argument value.
			SessionSecret string
		}
	}
	lockCreateSession      sync.RWMutex
	lockDeleteSession      sync.RWMutex
	lockGenerateOAuthURL   sync.RWMutex
	lockGetChannelMembers  sync.RWMutex
	lockGetUserFromSession sync.RWMutex
	lockHandleCallback     sync.RWMutex
	lockValidateSession    sync.RWMutex
}

// CreateSession calls CreateSessionFunc.
func (mock *AuthMock) CreateSession(ctx context.Context, slackUserID string, userName string, userEmail string) (*model.Session, error) {
	if mock.CreateSessionFunc == nil {
		panic("AuthMock.CreateSessionFunc: method is nil but Auth.CreateSession was just called")
	}
	callInfo := struct {
		Ctx         context.Context
		SlackUserID string
		UserName    string
		UserEmail   string
	}{
		Ctx:         ctx,
		SlackUserID: slackUserID,
		UserName:    userName,
		UserEmail:   userEmail,
	}
	mock.lockCreateSession.Lock()
	mock.calls.CreateSession = append(mock.calls.CreateSession, callInfo)
	mock.lockCreateSession.Unlock()
	return mock.CreateSessionFunc(ctx, slackUserID, userName, userEmail)
}

// CreateSessionCalls gets all the calls that were made to CreateSession.
// Check the length with:
//
//	len(mockedAuth.CreateSessionCalls())
func (mock *AuthMock) CreateSessionCalls() []struct {
	Ctx         context.Context
	SlackUserID string
	UserName    string
	UserEmail   string
} {
	var calls []struct {
		Ctx         context.Context
		SlackUserID string
		UserName    string
		UserEmail   string
	}
	mock.lockCreateSession.RLock()
	calls = mock.calls.CreateSession
	mock.lockCreateSession.RUnlock()
	return calls
}

// DeleteSession calls DeleteSessionFunc.
func (mock *AuthMock) DeleteSession(ctx context.Context, sessionID string) error {
	if mock.DeleteSessionFunc == nil {
		panic("AuthMock.DeleteSessionFunc: method is nil but Auth.DeleteSession was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		SessionID string
	}{
		Ctx:       ctx,
		SessionID: sessionID,
	}
	mock.lockDeleteSession.Lock()
	mock.calls.DeleteSession = append(mock.calls.DeleteSession, callInfo)
	mock.lockDeleteSession.Unlock()
	return mock.DeleteSessionFunc(ctx, sessionID)
}

// DeleteSessionCalls gets all the calls that were made to DeleteSession.
// Check the length with:
//
//	len(mockedAuth.DeleteSessionCalls())
func (mock *AuthMock) DeleteSessionCalls() []struct {
	Ctx       context.Context
	SessionID string
} {
	var calls []struct {
		Ctx       context.Context
		SessionID string
	}
	mock.lockDeleteSession.RLock()
	calls = mock.calls.DeleteSession
	mock.lockDeleteSession.RUnlock()
	return calls
}

// GenerateOAuthURL calls GenerateOAuthURLFunc.
func (mock *AuthMock) GenerateOAuthURL(ctx context.Context, config interfaces.OAuthConfig) (*interfaces.OAuthURL, error) {
	if mock.GenerateOAuthURLFunc == nil {
		panic("AuthMock.GenerateOAuthURLFunc: method is nil but Auth.GenerateOAuthURL was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Config interfaces.OAuthConfig
	}{
		Ctx:    ctx,
		Config: config,
	}
	mock.lockGenerateOAuthURL.Lock()
	mock.calls.GenerateOAuthURL = append(mock.calls.GenerateOAuthURL, callInfo)
	mock.lockGenerateOAuthURL.Unlock()
	return mock.GenerateOAuthURLFunc(ctx, config)
}

// GenerateOAuthURLCalls gets all the calls that were made to GenerateOAuthURL.
// Check the length with:
//
//	len(mockedAuth.GenerateOAuthURLCalls())
func (mock *AuthMock) GenerateOAuthURLCalls() []struct {
	Ctx    context.Context
	Config interfaces.OAuthConfig
} {
	var calls []struct {
		Ctx    context.Context
		Config interfaces.OAuthConfig
	}
	mock.lockGenerateOAuthURL.RLock()
	calls = mock.calls.GenerateOAuthURL
	mock.lockGenerateOAuthURL.RUnlock()
	return calls
}

// GetChannelMembers calls GetChannelMembersFunc.
func (mock *AuthMock) GetChannelMembers(ctx context.Context, channelID string) ([]*model.User, error) {
	if mock.GetChannelMembersFunc == nil {
		panic("AuthMock.GetChannelMembersFunc: method is nil but Auth.GetChannelMembers was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		ChannelID string
	}{
		Ctx:       ctx,
		ChannelID: channelID,
	}
	mock.lockGetChannelMembers.Lock()
	mock.calls.GetChannelMembers = append(mock.calls.GetChannelMembers, callInfo)
	mock.lockGetChannelMembers.Unlock()
	return mock.GetChannelMembersFunc(ctx, channelID)
}

// GetChannelMembersCalls gets all the calls that were made to GetChannelMembers.
// Check the length with:
//
//	len(mockedAuth.GetChannelMembersCalls())
func (mock *AuthMock) GetChannelMembersCalls() []struct {
	Ctx       context.Context
	ChannelID string
} {
	var calls []struct {
		Ctx       context.Context
		ChannelID string
	}
	mock.lockGetChannelMembers.RLock()
	calls = mock.calls.GetChannelMembers
	mock.lockGetChannelMembers.RUnlock()
	return calls
}

// GetUserFromSession calls GetUserFromSessionFunc.
func (mock *AuthMock) GetUserFromSession(ctx context.Context, sessionID string) (*model.User, error) {
	if mock.GetUserFromSessionFunc == nil {
		panic("AuthMock.GetUserFromSessionFunc: method is nil but Auth.GetUserFromSession was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		SessionID string
	}{
		Ctx:       ctx,
		SessionID: sessionID,
	}
	mock.lockGetUserFromSession.Lock()
	mock.calls.GetUserFromSession = append(mock.calls.GetUserFromSession, callInfo)
	mock.lockGetUserFromSession.Unlock()
	return mock.GetUserFromSessionFunc(ctx, sessionID)
}

// GetUserFromSessionCalls gets all the calls that were made to GetUserFromSession.
// Check the length with:
//
//	len(mockedAuth.GetUserFromSessionCalls())
func (mock *AuthMock) GetUserFromSessionCalls() []struct {
	Ctx       context.Context
	SessionID string
} {
	var calls []struct {
		Ctx       context.Context
		SessionID string
	}
	mock.lockGetUserFromSession.RLock()
	calls = mock.calls.GetUserFromSession
	mock.lockGetUserFromSession.RUnlock()
	return calls
}

// HandleCallback calls HandleCallbackFunc.
func (mock *AuthMock) HandleCallback(ctx context.Context, code string, redirectURI string) (*model.User, error) {
	if mock.HandleCallbackFunc == nil {
		panic("AuthMock.HandleCallbackFunc: method is nil but Auth.HandleCallback was just called")
	}
	callInfo := struct {
		Ctx         context.Context
		Code        string
		RedirectURI string
	}{
		Ctx:         ctx,
		Code:        code,
		RedirectURI: redirectURI,
	}
	mock.lockHandleCallback.Lock()
	mock.calls.HandleCallback = append(mock.calls.HandleCallback, callInfo)
	mock.lockHandleCallback.Unlock()
	return mock.HandleCallbackFunc(ctx, code, redirectURI)
}

// HandleCallbackCalls gets all the calls that were made to HandleCallback.
// Check the length with:
//
//	len(mockedAuth.HandleCallbackCalls())
func (mock *AuthMock) HandleCallbackCalls() []struct {
	Ctx         context.Context
	Code        string
	RedirectURI string
} {
	var calls []struct {
		Ctx         context.Context
		Code        string
		RedirectURI string
	}
	mock.lockHandleCallback.RLock()
	calls = mock.calls.HandleCallback
	mock.lockHandleCallback.RUnlock()
	return calls
}

// ValidateSession calls ValidateSessionFunc.
func (mock *AuthMock) ValidateSession(ctx context.Context, sessionID string, sessionSecret string) (*model.Session, error) {
	if mock.ValidateSessionFunc == nil {
		panic("AuthMock.ValidateSessionFunc: method is nil but Auth.ValidateSession was just called")
	}
	callInfo := struct {
		Ctx           context.Context
		SessionID     string
		SessionSecret string
	}{
		Ctx:           ctx,
		SessionID:     sessionID,
		SessionSecret: sessionSecret,
	}
	mock.lockValidateSession.Lock()
	mock.calls.ValidateSession = append(mock.calls.ValidateSession, callInfo)
	mock.lockValidateSession.Unlock()
	return mock.ValidateSessionFunc(ctx, sessionID, sessionSecret)
}

// ValidateSessionCalls gets all the calls that were made to ValidateSession.
// Check the length with:
//
//	len(mockedAuth.ValidateSessionCalls())
func (mock *AuthMock) ValidateSessionCalls() []struct {
	Ctx           context.Context
	SessionID     string
	SessionSecret string
} {
	var calls []struct {
		Ctx           context.Context
		SessionID     string
		SessionSecret string
	}
	mock.lockValidateSession.RLock()
	calls = mock.calls.ValidateSession
	mock.lockValidateSession.RUnlock()
	return calls
}
